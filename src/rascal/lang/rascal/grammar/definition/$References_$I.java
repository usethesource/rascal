package rascal.lang.rascal.grammar.definition;
import io.usethesource.vallang.*;
import org.rascalmpl.runtime.function.*;

@SuppressWarnings("unused")
public interface $References_$I  {
    IValue addLabels(IValue $0, IValue $1);
    IValue addParamLabels(IValue $0, IValue $1);
    IValue allLabeled(IValue $0);
    IValue associativity(IValue $0, IValue $1, IValue $2);
    IValue choice(IValue $0, IValue $1);
    IValue comparable(IValue $0, IValue $1);
    IValue compose(IValue $0, IValue $1);
    IValue concat(IValue $0);
    IValue delete(IValue $0, IValue $1);
    IValue dependencies(IValue $0);
    IValue distribution(IValue $0);
    IValue drop(IValue $0, IValue $1);
    IValue dup(IValue $0);
    IValue elementAt(IValue $0, IValue $1);
    IValue eq(IValue $0, IValue $1);
    IValue equivalent(IValue $0, IValue $1);
    IValue $extends(IValue $0);
    IValue firstAmbiguity(IValue $0, IValue $1);
    IValue firstAmbiguityFinder(IValue $0, java.util.Map<java.lang.String,IValue> $kwpActuals);
    IValue firstAmbiguityFinders(IValue $0, java.util.Map<java.lang.String,IValue> $kwpActuals);
    IValue getFirstFrom(IValue $0);
    IValue getLabels(IValue $0);
    IValue getOneFrom(IValue $0);
    IValue getParamLabels(IValue $0);
    IValue glb(IValue $0, IValue $1);
    IValue grammar(IValue $0, IValue $1);
    IValue grammar(IValue $0);
    IValue head(IValue $0, IValue $1);
    IValue head(IValue $0);
    IValue headTail(IValue $0);
    IValue implode(IValue $0, IValue $1);
    IValue imports(IValue $0);
    IValue index(IValue $0);
    IValue indexOf(IValue $0, IValue $1);
    IValue insertAt(IValue $0, IValue $1, IValue $2);
    IValue intercalate(IValue $0, IValue $1);
    IValue intersperse(IValue $0, IValue $1);
    IValue isADTType(IValue $0);
    IValue isAliasType(IValue $0);
    IValue isBagType(IValue $0);
    IValue isBoolType(IValue $0);
    IValue isConstructorType(IValue $0);
    IValue isDateTimeType(IValue $0);
    IValue isEmpty(IValue $0);
    IValue isFunctionType(IValue $0);
    IValue isIntType(IValue $0);
    IValue isListRelType(IValue $0);
    IValue isListType(IValue $0);
    IValue isLocType(IValue $0);
    IValue isMapType(IValue $0);
    IValue isNodeType(IValue $0);
    IValue isNonTerminalType(IValue $0);
    IValue isNumType(IValue $0);
    IValue isRatType(IValue $0);
    IValue isRealType(IValue $0);
    IValue isReifiedType(IValue $0);
    IValue isRelType(IValue $0);
    IValue isSetType(IValue $0);
    IValue isSorted(IValue $0, java.util.Map<java.lang.String,IValue> $kwpActuals);
    IValue isStrType(IValue $0);
    IValue isTupleType(IValue $0);
    IValue isTypeVar(IValue $0);
    IValue isValueType(IValue $0);
    IValue isVoidType(IValue $0);
    IValue itoString(IValue $0);
    IValue keepParams(IValue $0, IValue $1);
    IValue last(IValue $0);
    IValue lastIndexOf(IValue $0, IValue $1);
    IValue loadParser(IValue $0, IValue $1, java.util.Map<java.lang.String,IValue> $kwpActuals);
    IValue loadParsers(IValue $0, java.util.Map<java.lang.String,IValue> $kwpActuals);
    IValue lub(IValue $0, IValue $1);
    IValue mainMessageHandler(IValue $0, java.util.Map<java.lang.String,IValue> $kwpActuals);
    IValue make(IValue $0, IValue $1, IValue $2);
    IValue make(IValue $0, IValue $1, IValue $2, IValue $3);
    IValue mapper(IValue $0, IValue $1);
    IValue max(IValue $0);
    IValue merge(IValue $0, IValue $1);
    IValue merge(IValue $0, IValue $1, IValue $2);
    IValue min(IValue $0);
    IValue mix(IValue $0, IValue $1);
    IValue noneLabeled(IValue $0);
    IValue parse(IValue $0, IValue $1, java.util.Map<java.lang.String,IValue> $kwpActuals);
    IValue parse(IValue $0, IValue $1, IValue $2, java.util.Map<java.lang.String,IValue> $kwpActuals);
    IValue parser(IValue $0, java.util.Map<java.lang.String,IValue> $kwpActuals);
    IValue parsers(IValue $0, java.util.Map<java.lang.String,IValue> $kwpActuals);
    IValue permutations(IValue $0);
    IValue permutationsBag(IValue $0);
    IValue pop(IValue $0);
    IValue prefix(IValue $0);
    IValue printSymbol(IValue $0, IValue $1);
    IValue priority(IValue $0, IValue $1);
    IValue push(IValue $0, IValue $1);
    IValue reducer(IValue $0, IValue $1, IValue $2);
    IValue references(IValue $0);
    IValue remove(IValue $0, IValue $1);
    IValue removeFromBag(IValue $0, IValue $1);
    IValue removeFromBag(IValue $0, IValue $1, IValue $2);
    IValue reverse(IValue $0);
    IValue sameType(IValue $0, IValue $1);
    IValue shuffle(IValue $0);
    IValue shuffle(IValue $0, IValue $1);
    IValue size(IValue $0);
    IValue slice(IValue $0, IValue $1, IValue $2);
    IValue sort(IValue $0, IValue $1);
    IValue sort(IValue $0);
    IValue split(IValue $0);
    void storeParsers(IValue $0, IValue $1);
    IValue stripLabels(IValue $0);
    IValue subtype(IValue $0, IValue $1);
    IValue sum(IValue $0);
    IValue tail(IValue $0);
    IValue tail(IValue $0, IValue $1);
    IValue take(IValue $0, IValue $1);
    IValue takeOneFrom(IValue $0);
    IValue takeWhile(IValue $0, IValue $1);
    IValue toMap(IValue $0);
    IValue toMapUnique(IValue $0);
    IValue toRel(IValue $0);
    IValue toSet(IValue $0);
    IValue toString(IValue $0);
    IValue top(IValue $0);
    IValue treeAt(IValue $0, IValue $1, IValue $2);
    IValue typeCast(IValue $0, IValue $1);
    IValue typeOf(IValue $0);
    IValue unparse(IValue $0);
    IValue unzip2(IValue $0);
    IValue unzip3(IValue $0);
    IValue upTill(IValue $0);
    IValue var_func(IValue $0, IValue $1, IValue $2);
    IValue write(IValue $0, java.util.Map<java.lang.String,IValue> $kwpActuals);
    IValue zip2(IValue $0, IValue $1);
    IValue zip3(IValue $0, IValue $1, IValue $2);
}