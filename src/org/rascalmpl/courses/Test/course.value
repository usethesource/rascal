course("Test",["\<a href=\"/Test/Test.html\"\>Test\</a\>/\<a href=\"/Test/Cat1/Cat1.html\"\>Cat1\</a\>/\<a href=\"/Test/Cat1/Cat11/Cat11.html\"\>Cat11\</a\>: Reference to unknown course or concept: Test:Cat3","\<a href=\"/Test/Test.html\"\>Test\</a\>/\<a href=\"/Test/Cat2/Cat2.html\"\>Cat2\</a\>: Warning in Cat2","\<a href=\"/Test/Test.html\"\>Test\</a\>/\<a href=\"/Test/Libraries/Libraries.html\"\>Libraries\</a\>/\<a href=\"/Test/Libraries/lang/lang.html\"\>lang\</a\>/\<a href=\"/Test/Libraries/lang/csv/csv.html\"\>csv\</a\>/\<a href=\"/Test/Libraries/lang/csv/IO/IO.html\"\>IO\</a\>/\<a href=\"/Test/Libraries/lang/csv/IO/readCSV/readCSV.html\"\>readCSV\</a\>: PathNotFound(|std:///Rascal/Libraries/lang/csv/ex1.csv|): L = |std:///Rascal/Libraries/lang/csv/ex1.csv|, File Rascal/Libraries/lang/csv/ex1.csv.","\<a href=\"/Test/Test.html\"\>Test\</a\>/\<a href=\"/Test/Libraries/Libraries.html\"\>Libraries\</a\>/\<a href=\"/Test/Libraries/lang/lang.html\"\>lang\</a\>/\<a href=\"/Test/Libraries/lang/csv/csv.html\"\>csv\</a\>/\<a href=\"/Test/Libraries/lang/csv/IO/IO.html\"\>IO\</a\>: Unkown or ambiguous concept in toc: Rascal/Library/lang/csv/IO","\<a href=\"/Test/Test.html\"\>Test\</a\>/\<a href=\"/Test/Libraries/Libraries.html\"\>Libraries\</a\>/\<a href=\"/Test/Libraries/List/List.html\"\>List\</a\>/\<a href=\"/Test/Libraries/List/index/index.html\"\>index\</a\>: Reference to unknown course or concept: Test:For","\<a href=\"/Test/Test.html\"\>Test\</a\>/\<a href=\"/Test/Libraries/Libraries.html\"\>Libraries\</a\>/\<a href=\"/Test/Libraries/List/List.html\"\>List\</a\>/\<a href=\"/Test/Libraries/List/reducer/reducer.html\"\>reducer\</a\>: Reference to unknown course or concept: Test:Expressions/Reducer","\<a href=\"/Test/Test.html\"\>Test\</a\>/\<a href=\"/Test/AAA/AAA.html\"\>AAA\</a\>: screen command failed: \"xxx;\"","\<a href=\"/Test/Test.html\"\>Test\</a\>/\<a href=\"/Test/AAA/AAA.html\"\>AAA\</a\>: Reference to unknown course or concept: Test:WRONGLINK","\<a href=\"/Test/Test.html\"\>Test\</a\>/\<a href=\"/Test/AAA/AAA.html\"\>AAA\</a\>: Ambiguous reference to concept: Rascal:Comprehension; \nResolve with one of {Rascal/Expressions/Values/Set/Comprehension, Rascal/Expressions/Values/Map/Comprehension, Rascal/Expressions/Values/List/Comprehension}","\<a href=\"/Test/Test.html\"\>Test\</a\>/\<a href=\"/Test/AAA/AAA.html\"\>AAA\</a\>: Reference to unknown course or concept: Rascal:Zap","\<a href=\"/Test/Test.html\"\>Test\</a\>/\<a href=\"/Test/AAA/AAA.html\"\>AAA\</a\>: Hier is een warning in AAA","\<a href=\"/Test/Test.html\"\>Test\</a\>/\<a href=\"/Test/AAA/AAA.html\"\>AAA\</a\>: Hier is warning 2 in AAA","\<a href=\"/Test/Test.html\"\>Test\</a\>/\<a href=\"/Test/AAA/AAA.html\"\>AAA\</a\>: Hier is warning 3 in AAA","\<a href=\"/Test/Test.html\"\>Test\</a\>/\<a href=\"/Test/AAA/AAA.html\"\>AAA\</a\>: Hier is warning 4 in AAA","\<a href=\"/Test/Test.html\"\>Test\</a\>/\<a href=\"/Test/AAA/AAA.html\"\>AAA\</a\>: Ambiguous reference to concept: Test:Cat1; \nResolve with one of {Test/BBB/Cat1, Test/Cat1}","\<a href=\"/Test/Test.html\"\>Test\</a\>: Unkown or ambiguous concept in toc: XXX","\<a href=\"/Test/Test.html\"\>Test\</a\>: non-existing detail NotThere","\<a href=\"/Test/Test.html\"\>Test\</a\>/\<a href=\"/Test/Libraries/Libraries.html\"\>Libraries\</a\>/\<a href=\"/Test/Libraries/lang/lang.html\"\>lang\</a\>/\<a href=\"/Test/Libraries/lang/csv/csv.html\"\>csv\</a\>/\<a href=\"/Test/Libraries/lang/csv/IO/IO.html\"\>IO\</a\>/\<a href=\"/Test/Libraries/lang/csv/IO/writeCSV/writeCSV.html\"\>writeCSV\</a\>: PathNotFound(|std:///Rascal/Libraries/lang/csv/ex1a.csv|): L = |std:///Rascal/Libraries/lang/csv/ex1a.csv|, File Rascal/Libraries/lang/csv/ex1a.csv.","\<a href=\"/Test/Test.html\"\>Test\</a\>/\<a href=\"/Test/Libraries/Libraries.html\"\>Libraries\</a\>/\<a href=\"/Test/Libraries/lang/lang.html\"\>lang\</a\>/\<a href=\"/Test/Libraries/lang/csv/csv.html\"\>csv\</a\>/\<a href=\"/Test/Libraries/lang/csv/IO/IO.html\"\>IO\</a\>/\<a href=\"/Test/Libraries/lang/csv/IO/writeCSV/writeCSV.html\"\>writeCSV\</a\>: PathNotFound(|std:///Rascal/Libraries/lang/csv/ex1b.csv|): L = |std:///Rascal/Libraries/lang/csv/ex1b.csv|, File Rascal/Libraries/lang/csv/ex1b.csv."],("Test/Cat1/Cat11":concept("Test/Cat1/Cat11",["Reference to unknown course or concept: Test:Cat3"],[],{},[]),"Test/Libraries/List/mapper":concept("Test/Libraries/List/mapper",[],[],{},[tvQuestion("Test/Libraries/List/mapper","1",typeOfExpr(),details(" ",["import List;"],"int incr(int x) { return x + 1; }\n","","mapper(\<L\>, incr)","",false,false,[<"L",list(int(-20,20),1,5)>],[],same("L"),"")),tvQuestion("Test/Libraries/List/mapper","2",valueOfExpr(),details(" ",["import List;"],"int incr(int x) { return x + 1; }\n","","mapper(\<L\>, incr) == ","",false,true,[<"L",list(int(-20,20),1,5)>],[<"H","mapper(\<L\>, int(int n){ return n + 1; })">],void(),"\<H\>"))]),"Test/Exam":concept("Test/Exam",[],[],{},[textQuestion("Test/Exam","A"," Dit is een vraag. Wat is het antwoord?\n",{"antwoord"}),choiceQuestion("Test/Exam","2","  Sets can be used to represent a sequence of values when\n",[good("The values have no duplicates and no order."),bad("The values have duplicates."),bad("The values are unordered.")]),tvQuestion("Test/Exam","B",typeOfExpr(),details(" ",[],"","","\<A:int\>","",false,false,[<"A",int(-20,20)>],[],void(),"")),tvQuestion("Test/Exam","4",valueOfExpr(),details(" ",[],"","","2 * \<A:int\>","",false,false,[<"A",int(-20,20)>],[],void(),"")),tvQuestion("Test/Exam","5",typeOfExpr(),details(" ",[],"","","\<A:set[arb[int,str,real]]\>","",false,false,[<"A",set(arb(0,[int(-20,20),str(),real(-20,20)]),1,5)>],[],void(),""))]),"Test/T20111128":concept("Test/T20111128",[],[],{},[choiceQuestion("Test/T20111128","1","  A list:\n",[good("Has elements that are ordered."),good("Can contain zero or more elements."),good("Can contain duplicate elements."),bad("Has elements that are unordered."),bad("Can contain one or more elements."),bad("Can not contain duplicate elements.")]),choiceQuestion("Test/T20111128","2","  A map maps keys to values. In a map:\n",[good("All keys have to be unique."),good("All (key, value) pairs are unordered."),bad("All values have to be unique."),bad("All keys and values have to be unique."),bad("All keys are ordered."),bad("All values are ordered."),bad("All (key, value) pairs are ordered.")]),choiceQuestion("Test/T20111128","3","  A relation:\n",[good("Is a set of tuples."),good("Has unordered elements."),good("Can not contain duplicates."),bad("Is a list of tuples."),bad("Is a tuple of tuples."),bad("Has ordered elements."),bad("Can contain duplicates.")]),choiceQuestion("Test/T20111128","4","  The following statement about subtypes is correct:\n",[good("`int` is a subtype of `num`."),good("`real` is a subtype of `number`."),good("`int` is a subtype of `real`."),good("`num` is a subtype of `value`."),good("An Algebraic Data Type (defined using `data`) is a subtype of `node`."),good("A relation is a subtype of set."),bad("`bool` is a subtype of `int`."),bad("`num` is a subtype of `real`."),bad("`value` is a subtype of `void`.")]),choiceQuestion("Test/T20111128","5","  The type of a set is determined by:\n",[good("The least upperbound of the type of all elements."),good("The types of all the elements in the set."),bad("The average of the type of the elements with the smallest and the largest type."),bad("The least upperbound of the type of two arbitrary elements."),bad("The type of two arbitrary elements.")]),choiceQuestion("Test/T20111128","6","  Which statement about the domain and range function on a binary relation of type \<code\>rel[int,int]\</code\> is correct:\n",[good("Domain returns a set of the first element of each tuple in the relation and range returns a set of the second element of each tuple."),good("Domain and range are only applicable to binary relations."),bad("Domain returns a list of the first element of each tuple in the relation and range returns a list of the second element of each tuple."),bad("Domain returns a set of the second element of each tuple in the relation and range returns a set of the first element of each tuple."),bad("Domain returns a list of the second element of each tuple in the relation and range returns a list of the first element of each tuple."),bad("Domain returns a set of the elements that occur in any tuple in the relation and range returns a list of those elements.")]),tvQuestion("Test/T20111128","7",typeOfExpr(),details(" ",[],"","","\<A:list[arb[int,real,str,loc]]\>","",false,false,[<"A",list(arb(0,[int(-20,20),real(-20,20),str(),\loc()]),1,5)>],[],void(),"")),tvQuestion("Test/T20111128","8",typeOfExpr(),details(" ",[],"","","{\<A\>, ","}",false,true,[<"A",int(-20,20)>],[],set(num(-20,20),1,5),"")),tvQuestion("Test/T20111128","9",typeOfExpr(),details(" ",[],"","","{\<A\>, ","}",false,true,[<"A",int(-20,20)>],[],set(value(),1,5),"")),tvQuestion("Test/T20111128","10",typeOfExpr(),details(" ",[],"","","(\<A\>: ",")",false,true,[<"A",str()>],[],map(str(),int(-20,20)),"a map from strings to integers")),tvQuestion("Test/T20111128","11",typeOfExpr(),details(" ",[],"","","\<A:set[arb[int,real,num,str,loc]]\>","",false,false,[<"A",set(arb(0,[int(-20,20),real(-20,20),num(-20,20),str(),\loc()]),1,5)>],[],void(),"")),tvQuestion("Test/T20111128","12",valueOfExpr(),details(" Create a list of the right size.\n",[],"import List;\nlist[int] text = ",";\n","size(text) == 3;","",true,false,[],[],void(),"")),tvQuestion("Test/T20111128","13",valueOfExpr(),details(" Return the strings that contain a given substring.\n",[],"text = [\"An\", \"honest\", \"man\", \"is\", \"always\", \"a\", \"child\"]; \npublic list[str] find(list[str] text, str contains) = [ s | s \<- text, "," ];\n","find(text, \"s\") == [\"honest\", \"is\", \"always\"];","",true,false,[],[],void(),"")),tvQuestion("Test/T20111128","14",valueOfExpr(),details(" Return the list of words with a length smaller than or equal to \<code\>n\</code\>.\n",[],"import Number;\nimport String;\ntext = [\"Quote\", \"from\", \"Mahatma\", \"Gandhi:\", \n\"Freedom\", \"is\", \"not\", \"worth\", \"having\", \"if\", \"it\", \"does\", \"not\", \n\"include\", \"the\", \"freedom\", \"to\", \"make\", \"mistakes\"];\n\npublic list[str] smallerOrEq(list[str] text, int n){\n  return\n    for(s \<- text)\n        if(",")\n           append s;\n}\n","smallerOrEq(text, 3) == [\"is\", \"not\", \"if\", \"it\", \"not\", \"the\", \"to\"];","",true,false,[],[],void(),"")),tvQuestion("Test/T20111128","15",valueOfExpr(),details(" Complete this function that returns the set of keys with the largest associated value.\n",[],"import Map;\nimport Set;\ninventory = (\"orange\" : 20, \"apple\" : 15, \"banana\" : 25, \"lemon\" : 15);\npublic set[str] largest(map[str,int] inv){\n    m = ","; // Determine the maximal value in the map\n    return { s  | s \<- inv, inv[s] == m };\n}\n","largest(inventory) == {\"banana\"};","",true,false,[],[],void(),"")),tvQuestion("Test/T20111128","16",valueOfExpr(),details(" Complete this function that tests that a list of words consists of three identical sublists:\n",[],"import List;\npublic bool isTriple(list[str] words){\n  return [list[str] L, ","] := words;\n}\n","isTriple([\"a\", \"b\", \"a\", \"b\", \"a\", \"b\"]) == true;","",true,false,[],[],void(),"")),tvQuestion("Test/T20111128","17",valueOfExpr(),details(" Given a data type \<code\>ColoredTree\</code\>, complete the definition of the function \<code\>flipRedChildren\</code\> that exchanges the children of all black nodes.\n",[],"data ColoredTree = leaf(int N)      \n                 | red(ColoredTree left, ColoredTree right) \n                 | black(ColoredTree left, ColoredTree right);\n\nColoredTree rb = red(black(leaf(1), red(leaf(2),leaf(3))), black(leaf(3), leaf(4)));\n\npublic ColoredTree flipBlackChildren(ColoredTree t){\n  return visit(t){\n     case black(l,r) =\> ","\n  };\n}\n","flipBlackChildren(rb) ==  red(black(red(leaf(2),leaf(3)), leaf(1)), black(leaf(4), leaf(3)));","",true,false,[],[],void(),""))]),"Test/Cat2":concept("Test/Cat2",["Warning in Cat2"],[],{},[]),"Test/Cat1":concept("Test/Cat1",[],[],{},[]),"Test/Bla/Bla4":concept("Test/Bla/Bla4",[],[],{},[]),"Test/Bla/Bla3":concept("Test/Bla/Bla3",[],[],{},[]),"Test/Bla/Bla2":concept("Test/Bla/Bla2",[],[],{},[]),"Test/Bla/Bla1":concept("Test/Bla/Bla1",[],[],{},[]),"Test/Libraries/List/takeWhile":concept("Test/Libraries/List/takeWhile",[],[],{},[tvQuestion("Test/Libraries/List/takeWhile","1",typeOfExpr(),details(" ",["import List;"],"","","takeWhile(\<L\>, bool(int x){ return x \> 0;})","",false,false,[<"L",list(int(-20,20),1,5)>],[],void(),"")),tvQuestion("Test/Libraries/List/takeWhile","2",valueOfExpr(),details(" ",["import List;"],"","","takeWhile(\<L\>, bool(int x){ return x \> 0;}) == ","",false,true,[<"L",list(int(-20,20),1,5)>],[<"H","takeWhile(\<L\>, bool(int x){ return x \> 0;})">],void(),"\<H\>")),tvQuestion("Test/Libraries/List/takeWhile","3",valueOfExpr(),details(" ",["import List;"],"","","takeWhile(\<L\>, ",") == \<M\>",false,true,[<"L",list(int(-20,2),3,6)>],[<"M","takeWhile(\<L\>, bool(int x){ return x \< 0;})">],void(),"bool(int x){ return x \< 0;}"))]),"Test/Libraries/List/unzip":concept("Test/Libraries/List/unzip",[],[],{},[tvQuestion("Test/Libraries/List/unzip","1",typeOfExpr(),details(" ",["import List;"],"","","unzip(\<Z\>)","",false,false,[<"L",list(int(-20,20),4,4)>,<"M",list(int(-20,20),4,4)>],[<"Z","zip(\<L\>, \<M\>)">],void(),"")),tvQuestion("Test/Libraries/List/unzip","2",valueOfExpr(),details(" ",["import List;"],"","","unzip(\<Z\>) == ","",false,true,[<"L",list(int(-20,20),4,4)>,<"M",list(int(-20,20),4,4)>],[<"Z","zip(\<L\>, \<M\>)">,<"H","unzip(\<Z\>)">],void(),"\<H\>"))]),"Test/Libraries/List/toSet":concept("Test/Libraries/List/toSet",[],[],{},[tvQuestion("Test/Libraries/List/toSet","1",typeOfExpr(),details(" ",["import List;"],"","","toSet(\<L\>)","",false,false,[<"L",list(arb(0,[int(-20,20),str()]),1,5)>],[],void(),"")),tvQuestion("Test/Libraries/List/toSet","2",valueOfExpr(),details(" ",["import List;"],"","","toSet(\<L\>) == ","",false,true,[<"L",list(arb(0,[int(-20,20),str()]),1,5)>],[<"H","toSet(\<L\>)">],void(),"\<H\>"))]),"Test/Libraries/List/delete":concept("Test/Libraries/List/delete",[],[],{},[choiceQuestion("Test/Libraries/List/delete","1","  When you delete an element from a list, the number of elements:\n",[good("Decreases by one."),bad("Decreases with the number of occurrences of the deleted element."),bad("Stays the same."),bad("Increases by one.")]),tvQuestion("Test/Libraries/List/delete","2",typeOfExpr(),details(" ",["import List;"],"","","delete(\<L\>, \<I\>)","",false,false,[<"L",list(arb(0,[bool(),int(-20,20),str()]),4,6)>,<"I",int(0,3)>],[],void(),"")),tvQuestion("Test/Libraries/List/delete","3",valueOfExpr(),details(" ",["import List;"],"","","delete(\<L\>, \<I\>) == ","",false,true,[<"L",list(arb(0,[bool(),int(-20,20),str()]),4,6)>,<"I",int(0,3)>],[<"C","delete(\<L\>, \<I\>)">],void(),"\<C\>"))]),"Test/LinkBreak":concept("Test/LinkBreak",[],[],{},[]),"Test/Libraries/lang/csv/IO/generate":concept("Test/Libraries/lang/csv/IO/generate",[],[],{},[]),"Test/Libraries/List/max":concept("Test/Libraries/List/max",[],[],{},[tvQuestion("Test/Libraries/List/max","1",typeOfExpr(),details(" ",["import List;"],"","","max(\<L\>)","",false,false,[<"L",list(arb(0,[int(-20,20),str()]),1,6)>],[],void(),"")),tvQuestion("Test/Libraries/List/max","2",valueOfExpr(),details(" ",["import List;"],"","","max(\<L\>) == ","",false,true,[<"L",list(arb(0,[int(-20,20),str()]),1,6)>],[<"H","max(\<L\>)">],void(),"\<H\>"))]),"Test/BBB/Cat1":concept("Test/BBB/Cat1",[],[],{},[]),"Test/Libraries/List/reverse":concept("Test/Libraries/List/reverse",[],[],{},[tvQuestion("Test/Libraries/List/reverse","1",typeOfExpr(),details(" ",["import List;"],"","","reverse(\<L\>)","",false,false,[<"L",list(arb(0,[int(-20,20),str()]),0,5)>],[],void(),"")),tvQuestion("Test/Libraries/List/reverse","2",valueOfExpr(),details(" ",["import List;"],"","","reverse(\<L\>) == ","",false,true,[<"L",list(arb(0,[int(-20,20),str()]),0,5)>],[<"H","reverse(\<L\>) ">],void(),"\<H\>"))]),"Test/Libraries/List/toMap":concept("Test/Libraries/List/toMap",[],[],{},[tvQuestion("Test/Libraries/List/toMap","1",typeOfExpr(),details(" ",["import List;"],"","","toMap(\<L\>)","",false,false,[<"L",list(tuple([int(-20,20),int(-20,20)]),5,8)>],[],void(),"")),tvQuestion("Test/Libraries/List/toMap","2",valueOfExpr(),details(" ",["import List;"],"","","toMap(\<L\>) == ","",false,true,[<"L",list(tuple([int(-20,20),int(-20,20)]),5,8)>],[<"H","toMap(\<L\>)">],void(),"\<H\>"))]),"Test/Libraries/List/intercalate":concept("Test/Libraries/List/intercalate",[],[],{},[tvQuestion("Test/Libraries/List/intercalate","1",valueOfExpr(),details(" ",["import List;"],"","","intercalate(\";\", \<L\>) == ","",false,true,[<"L",list(int(-20,20),0,5)>],[<"H","intercalate(\";\", \<L\>) ">],void(),"\<H\>"))]),"Test/Cat2/Cat22":concept("Test/Cat2/Cat22",[],[],{},[]),"Test/Cat2/Cat21":concept("Test/Cat2/Cat21",[],[],{},[]),"Test/Libraries/lang/csv/IO/readCSV":concept("Test/Libraries/lang/csv/IO/readCSV",["PathNotFound(|std:///Rascal/Libraries/lang/csv/ex1.csv|): L = |std:///Rascal/Libraries/lang/csv/ex1.csv|, File Rascal/Libraries/lang/csv/ex1.csv."],[],{},[]),"Test/Libraries/List/mix":concept("Test/Libraries/List/mix",[],[],{},[choiceQuestion("Test/Libraries/List/mix","1","  Given two lists of length \<code\>\<i\>N\</i\>\</code\>, respectively, \<code\>\<i\>M\</i\>\</code\>. What is the length of the mixed list:\n",[good("N + M."),bad("N + M - 1."),bad("N."),bad("M."),bad("N * M.")]),tvQuestion("Test/Libraries/List/mix","2",typeOfExpr(),details(" ",["import List;"],"","","mix(\<L\>, \<M\>)","",false,false,[<"L",list(arb(0,[int(-20,20),str()]),1,5)>,<"M",same("L")>],[],void(),"")),tvQuestion("Test/Libraries/List/mix","3",valueOfExpr(),details(" ",["import List;"],"","","mix(\<L\>, \<M\>) == ","",false,true,[<"L",list(arb(0,[int(-20,20),str()]),1,5)>,<"M",same("L")>],[<"H","mix(\<L\>, \<M\>)">],void(),"\<H\>"))]),"Test/Libraries/lang/csv/IO":concept("Test/Libraries/lang/csv/IO",["Unkown or ambiguous concept in toc: Rascal/Library/lang/csv/IO"],[],{},[]),"Test/Libraries/lang/xml/DOM":concept("Test/Libraries/lang/xml/DOM",[],[],{},[]),"Test/Libraries":concept("Test/Libraries",[],[],{},[]),"Test/Libraries/List/sort":concept("Test/Libraries/List/sort",[],[],{},[choiceQuestion("Test/Libraries/List/sort","1","  Sorting a listing with \<code\>\<i\>N\</i\>\</code\> elements gives a list with:\n",[good("N elements."),bad("N - 1 elements."),bad("N! elements."),bad("N * (N - 1) elements.")]),tvQuestion("Test/Libraries/List/sort","2",typeOfExpr(),details(" ",["import List;"],"","","sort(\<L\>)","",false,false,[<"L",list(arb(0,[int(-20,20),str()]),1,5)>],[],void(),"")),tvQuestion("Test/Libraries/List/sort","3",valueOfExpr(),details(" ",["import List;"],"","","sort(\<L\>) == ","",false,true,[<"L",list(arb(0,[int(-20,20),str()]),1,5)>],[<"H","sort(\<L\>)">],void(),"\<H\>"))]),"Test/Bla":concept("Test/Bla",[],[],{},[]),"Test/T20111114":concept("Test/T20111114",[],[],{},[choiceQuestion("Test/T20111114","1","  A map maps keys to values. In a map:\n",[good("All keys have to be unique."),good("All keys have the same type."),good("All keys should have the same type and all values should have the same type. The type of keys and values may be different."),bad("All keys should have the same type and all values should have the same type. The type of keys and values should be the same."),bad("All values have to be unique."),bad("All keys and values have to be unique."),bad("All keys are sorted.")]),choiceQuestion("Test/T20111114","2","  In a tuple:\n",[good("All elements may have different types."),good("The number of elements is fixed."),good("The order of the elements is relevant."),bad("All elements should have the same type."),bad("The number of elements is not fixed."),bad("The order of the elements is not relevant.")]),choiceQuestion("Test/T20111114","3","  A relation:\n",[good("Is a set of tuples."),good("Has unordered elements."),good("Can not contain duplicates."),bad("Is a list of tuples."),bad("Is a tuple of tuples."),bad("Has ordered elements."),bad("Can contain duplicates."),bad("Has a fixed length.")]),choiceQuestion("Test/T20111114","4","  The type of a set is determined by:\n",[good("The least upperbound of the type of all elements."),good("The types of all the elements in the set."),bad("The type of the element that was first added to the set."),bad("The average of the type of the elements with the smallest and the largests type."),bad("The least upperbound of the type of two arbitrary elements."),bad("The type of two arbitrary elements.")]),choiceQuestion("Test/T20111114","5","  Which statement about the domain and range function on a binary relation of type \<code\>rel[int,int]\</code\> is correct:\n",[good("Domain returns a set of the first element of each tuple in the relation and range returns a set of the second element of each tuple."),good("Domain and range are only applicable to binary relations."),bad("Domain returns a list of the first element of each tuple in the relation and range returns a list of the second element of each tuple."),bad("Domain returns a set of the second element of each tuple in the relation and range returns a set of the first element of each tuple."),bad("Domain returns a list of the second element of each tuple in the relation and range returns a list of the first element of each tuple."),bad("Domain returns a set of the elements that occur in any tuple in the relation and range returns a list of those elements.")]),tvQuestion("Test/T20111114","6",typeOfExpr(),details(" ",[],"","","\<A:list[arb[int,real,str,loc]]\>","",false,false,[<"A",list(arb(0,[int(-20,20),real(-20,20),str(),\loc()]),1,5)>],[],void(),"")),tvQuestion("Test/T20111114","7",typeOfExpr(),details(" ",[],"","","{\<A\>, ","}",false,true,[<"A",int(-20,20)>],[],set(num(-20,20),1,5),"")),tvQuestion("Test/T20111114","8",typeOfExpr(),details(" ",[],"","","{\<A\>, ","}",false,true,[<"A",int(-20,20)>],[],set(value(),1,5),"")),tvQuestion("Test/T20111114","9",typeOfExpr(),details(" ",[],"","","(\<A\>: ",")",false,true,[<"A",str()>],[],map(str(),int(-20,20)),"a map from strings to integers")),tvQuestion("Test/T20111114","10",typeOfExpr(),details(" ",[],"","","\<A:set[arb[int,real,num,str,loc]]\>","",false,false,[<"A",set(arb(0,[int(-20,20),real(-20,20),num(-20,20),str(),\loc()]),1,5)>],[],void(),"")),tvQuestion("Test/T20111114","11",valueOfExpr(),details(" Create a list of the right size.\n",[],"import List;\nlist[str] text = ",";\n","size(text) == 3;","",true,false,[],[],void(),"")),tvQuestion("Test/T20111114","12",valueOfExpr(),details(" Return the strings that contain a given substring.\n",[],"text = [\"An\", \"honest\", \"man\", \"is\", \"always\", \"a\", \"child\"]; \npublic list[str] find(list[str] text, str contains) = [ s | s \<- text, "," ];\n","find(text, \"n\") == [\"An\", \"honest\", \"man\"];","",true,false,[],[],void(),"")),tvQuestion("Test/T20111114","13",valueOfExpr(),details(" Return the set of largest words.\n",[],"import Number;\nimport String;\ntext = [\"Quote\", \"from\", \"Steve\", \"Jobs\", \":\", \"And\", \"one\", \"more\", \"thing\"];\npublic list[str] largest(list[str] text){\n  mx = ( 0 | max(it, size(s)) | s \<- text );\n  return\n    for(s \<- text)\n        if(",")\n           append s;\n}\n","largest(text) == [\"Quote\", \"Steve\", \"thing\"];","",true,false,[],[],void(),"")),tvQuestion("Test/T20111114","14",valueOfExpr(),details(" Complete this function that returns the set of keys with the smallest associated value.\n",[],"import Map;\nimport Set;\ninventory = (\"orange\" : 20, \"apple\" : 15, \"banana\" : 25, \"lemon\" : 15);\npublic set[str] lowest(map[str,int] inv){\n    m = ","; // Determine the minimal value in the map\n    return { s  | s \<- inv, inv[s] == m };\n}\n","lowest(inventory) == {\"apple\", \"lemon\"};","",true,false,[],[],void(),"")),tvQuestion("Test/T20111114","15",valueOfExpr(),details(" Complete this function that tests that a list of words consists of two identical sublists:\n",[],"import List;\npublic bool isReplicated(list[str] words){\n  return [list[str] L, ","] := words;\n}\n","isReplicated([\"a\", \"b\", \"a\", \"b\"]) == true;","",true,false,[],[],void(),"")),tvQuestion("Test/T20111114","16",valueOfExpr(),details(" Given a data type \<code\>ColoredTree\</code\>, complete the definition of the function \<code\>flipRedChildren\</code\> that exchanges the children of all red nodes.\n",[],"data ColoredTree = leaf(int N)      \n                 | red(ColoredTree left, ColoredTree right) \n                 | black(ColoredTree left, ColoredTree right);\n\nColoredTree rb = red(black(leaf(1), red(leaf(2),leaf(3))), black(leaf(3), leaf(4)));\n\npublic ColoredTree flipRedChildren(ColoredTree t){\n  return visit(t){\n     case red(l,r) =\> ","\n  };\n}\n","flipRedChildren(rb) == red( black(leaf(3), leaf(4)), black(leaf(1), red(leaf(3),leaf(2))));","",true,false,[],[],void(),""))]),"Test/Libraries/List/push":concept("Test/Libraries/List/push",[],[],{},[tvQuestion("Test/Libraries/List/push","1",typeOfExpr(),details(" ",["import List;"],"","","push(\<E\>, \<L\>)","",false,false,[<"E",arb(0,[int(-20,20),str()])>,<"L",list(same("E"),1,5)>],[],void(),"")),tvQuestion("Test/Libraries/List/push","2",valueOfExpr(),details(" ",["import List;"],"","","push(\<E\>, \<L\>) == ","",false,true,[<"E",arb(0,[int(-20,20),str()])>,<"L",list(same("E"),1,5)>],[<"H","push(\<E\>, \<L\>)">],void(),"\<H\>"))]),"Test/Libraries/List/top":concept("Test/Libraries/List/top",[],[],{},[tvQuestion("Test/Libraries/List/top","1",typeOfExpr(),details(" ",["import List;"],"","","top(\<L\>)","",false,false,[<"L",list(arb(0,[int(-20,20),str()]),1,6)>],[],void(),"")),tvQuestion("Test/Libraries/List/top","2",valueOfExpr(),details(" ",["import List;"],"","","top(\<L\>) == ","",false,true,[<"L",list(arb(0,[int(-20,20),str()]),1,6)>],[<"H","top(\<L\>)">],void(),"\<H\>"))]),"Test/Libraries/List/lastIndexOf":concept("Test/Libraries/List/lastIndexOf",[],[],{},[tvQuestion("Test/Libraries/List/lastIndexOf","1",typeOfExpr(),details(" ",["import List;"],"","","lastIndexOf(\<L\>, \<E\>)","",false,false,[<"L",list(arb(0,[int(-20,20),str()]),4,6)>,<"I",int(0,3)>],[<"E","\<L\>[\<I\>]">],void(),"")),tvQuestion("Test/Libraries/List/lastIndexOf","2",valueOfExpr(),details(" ",["import List;"],"","","lastIndexOf(\<L1\>, \<E\>) == ","",false,true,[<"L",list(arb(0,[int(-20,20),str()]),3,4)>,<"I",int(0,2)>],[<"E","\<L\>[\<I\>]">,<"L1","reverse(\<L\>) + \<L\>">,<"H","lastIndexOf(\<L1\>, \<E\>)">],void(),"\<H\>"))]),"Test/Libraries/util":concept("Test/Libraries/util",[],[],{},[]),"Test/Libraries/List/index":concept("Test/Libraries/List/index",["Reference to unknown course or concept: Test:For"],[],{},[choiceQuestion("Test/Libraries/List/index","1","  The number of elements in the index of a list is:\n",[good("Equal to the number of elements in the list."),bad("Depends on the number of repeated elements in the list."),bad("One less than the number of elements in the list."),bad("One larger than the number of elements in the list.")]),tvQuestion("Test/Libraries/List/index","2",typeOfExpr(),details(" ",["import List;"],"","","index(\<L\>)","",false,false,[<"L",list(arb(0,[int(-20,20),str()]),3,5)>],[],void(),"")),tvQuestion("Test/Libraries/List/index","3",valueOfExpr(),details(" ",["import List;"],"","","index(\<L\>) == ","",false,true,[<"L",list(arb(0,[int(-20,20),str()]),0,5)>],[<"H","index(\<L\>)">],void(),"\<H\>"))]),"Test/Libraries/List/last":concept("Test/Libraries/List/last",[],[],{},[tvQuestion("Test/Libraries/List/last","1",typeOfExpr(),details(" ",["import List;"],"","","last(\<L\>)","",false,false,[<"L",list(arb(0,[int(-20,20),str()]),1,6)>],[],void(),"")),tvQuestion("Test/Libraries/List/last","2",valueOfExpr(),details(" ",["import List;"],"","","last(\<L\>) == ","",false,true,[<"L",list(arb(0,[int(-20,20),str()]),1,6)>],[<"H","last(\<L\>)">],void(),"\<H\>"))]),"Test/Libraries/List/min":concept("Test/Libraries/List/min",[],[],{},[tvQuestion("Test/Libraries/List/min","1",typeOfExpr(),details(" ",["import List;"],"","","min(\<L\>)","",false,false,[<"L",list(arb(0,[int(-20,20),str()]),1,6)>],[],void(),"")),tvQuestion("Test/Libraries/List/min","2",valueOfExpr(),details(" ",["import List;"],"","","min(\<L\>) == ","",false,true,[<"L",list(arb(0,[int(-20,20),str()]),1,6)>],[<"H","min(\<L\>)">],void(),"\<H\>"))]),"Test/Libraries/List/pop":concept("Test/Libraries/List/pop",[],[],{},[tvQuestion("Test/Libraries/List/pop","1",typeOfExpr(),details(" ",["import List;"],"","","pop(\<L\>)","",false,false,[<"L",list(arb(0,[int(-20,20),str()]),1,5)>],[],void(),"")),tvQuestion("Test/Libraries/List/pop","2",valueOfExpr(),details(" ",["import List;"],"","","pop(\<L\>) == ","",false,true,[<"L",list(arb(0,[int(-20,20),str()]),1,5)>],[<"H","pop(\<L\>)">],void(),"\<H\>"))]),"Test/Libraries/List/prefix":concept("Test/Libraries/List/prefix",[],[],{},[choiceQuestion("Test/Libraries/List/prefix","1","  Takking the prefix of a list with \<code\>\<i\>N\</i\>\</code\> elements returns a list with\n",[good("N-1 elements."),bad("N elements."),bad("N+1 elements."),bad("N * (N-1) elements.")]),tvQuestion("Test/Libraries/List/prefix","2",typeOfExpr(),details(" ",["import List;"],"","","prefix(\<L\>)","",false,false,[<"L",list(arb(0,[bool(),int(-20,20),str()]),4,6)>],[],void(),"")),tvQuestion("Test/Libraries/List/prefix","3",valueOfExpr(),details(" ",["import List;"],"","","prefix(\<L\>) == ","",false,true,[<"L",list(arb(0,[bool(),int(-20,20),str()]),4,6)>],[<"H","prefix(\<L\>)">],void(),"\<H\>"))]),"Test/Libraries/List/reducer":concept("Test/Libraries/List/reducer",["Reference to unknown course or concept: Test:Expressions/Reducer"],[],{},[]),"Test/Libraries/List/sum":concept("Test/Libraries/List/sum",[],[],{},[tvQuestion("Test/Libraries/List/sum","1",typeOfExpr(),details(" ",["import List;"],"","","sum(\<L\>)","",false,false,[<"L",list(num(-20,20),2,7)>],[],void(),"")),tvQuestion("Test/Libraries/List/sum","2",valueOfExpr(),details(" ",["import List;"],"","","sum(\<L\>)","",false,false,[<"L",list(int(-20,20),2,7)>],[<"H","sum(\<L\>)">],void(),"\<H\>"))]),"Test/Libraries/List/indexOf":concept("Test/Libraries/List/indexOf",[],[],{},[tvQuestion("Test/Libraries/List/indexOf","1",typeOfExpr(),details(" ",["import List;"],"","","indexOf(\<L\>, \<E\>)","",false,false,[<"L",list(arb(0,[int(-20,20),str()]),4,6)>,<"I",int(0,3)>],[<"E","\<L\>[\<I\>]">],void(),"")),tvQuestion("Test/Libraries/List/indexOf","2",valueOfExpr(),details(" ",["import List;"],"","","indexOf(\<L\>, \<E\>) == ","",false,true,[<"L",list(arb(0,[int(-20,20),str()]),4,6)>,<"I",int(0,3)>],[<"E","\<L\>[\<I\>]">,<"H","indexOf(\<L\>, \<E\>)">],void(),"\<H\>"))]),"Test/Libraries/lang/xml":concept("Test/Libraries/lang/xml",[],[],{},[]),"Test/Libraries/List/isEmpty":concept("Test/Libraries/List/isEmpty",[],[],{},[tvQuestion("Test/Libraries/List/isEmpty","1",typeOfExpr(),details(" ",["import List;"],"","","isEmpty(\<L\>)","",false,false,[<"L",list(arb(0,[int(-20,20),str()]),0,6)>],[],void(),"")),tvQuestion("Test/Libraries/List/isEmpty","2",valueOfExpr(),details(" ",["import List;"],"","","isEmpty(\<L\>) == ","",false,true,[<"L",list(arb(0,[int(-20,20),str()]),0,6)>],[<"H","isEmpty(\<L\>)">],void(),"\<H\>"))]),"Test/Libraries/List/take":concept("Test/Libraries/List/take",[],[],{},[choiceQuestion("Test/Libraries/List/take","1","  Computing \<code\>take(M, L)\</code\> of a list with \<code\>\<i\>N\</i\>\</code\> (\<code\>\<i\>N\</i\>\</code\> \> \<code\>\<i\>M\</i\>\</code\>) elements returns a list with\n",[good("M elements."),bad("N-M elements."),bad("N elements."),bad("N * M elements.")]),tvQuestion("Test/Libraries/List/take","2",typeOfExpr(),details(" ",["import List;"],"","","take(\<N\>, \<L\>)","",false,false,[<"L",list(arb(0,[bool(),int(-20,20),str()]),4,6)>,<"N",int(0,3)>],[],void(),"")),tvQuestion("Test/Libraries/List/take","3",valueOfExpr(),details(" ",["import List;"],"","","take(\<N\>, \<L\>) == ","",false,true,[<"L",list(arb(0,[bool(),int(-20,20),str()]),4,6)>,<"N",int(0,3)>],[<"H","take(\<N\>, \<L\>)">],void(),"\<H\>"))]),"Test/AAA":concept("Test/AAA",["screen command failed: \"xxx;\"","Reference to unknown course or concept: Test:WRONGLINK","Ambiguous reference to concept: Rascal:Comprehension; \nResolve with one of {Rascal/Expressions/Values/Set/Comprehension, Rascal/Expressions/Values/Map/Comprehension, Rascal/Expressions/Values/List/Comprehension}","Reference to unknown course or concept: Rascal:Zap","Hier is een warning in AAA","Hier is warning 2 in AAA","Hier is warning 3 in AAA","Hier is warning 4 in AAA","Ambiguous reference to concept: Test:Cat1; \nResolve with one of {Test/BBB/Cat1, Test/Cat1}"],[],{},[tvQuestion("Test/AAA","1",typeOfExpr(),details(" ",[],"","","\<A:set[arb[int,str,real]]\>","",false,false,[<"A",set(arb(0,[int(-20,20),str(),real(-20,20)]),1,5)>],[],void(),"")),tvQuestion("Test/AAA","2",typeOfExpr(),details(" ",[],"","","{1, "," }",false,true,[],[],set(int(-20,20),1,5),"one or more integer values separated by commas"))]),"Test/Libraries/List/distribution":concept("Test/Libraries/List/distribution",[],[],{},[]),"Test/Libraries/lang":concept("Test/Libraries/lang",[],[],{},[]),"Test/Libraries/List/size":concept("Test/Libraries/List/size",[],[],{},[tvQuestion("Test/Libraries/List/size","1",valueOfExpr(),details(" Create a list of the right size.\n",[],"import List;\nlist[str] text = ",";\n","size(text) == 3;","",true,false,[],[],void(),"")),tvQuestion("Test/Libraries/List/size","2",valueOfExpr(),details(" Determine the number of elements in a list\n",[],"import List;\ntext = [\"abc\", \"def\", \"ghi\"];\n","","","(text) == 3;",false,true,[],[],void(),""))]),"Test/ScreenTest":concept("Test/ScreenTest",[],[],{},[]),"Test/Libraries/List/merge":concept("Test/Libraries/List/merge",[],[],{},[tvQuestion("Test/Libraries/List/merge","1",typeOfExpr(),details(" ",["import List;"],"","","merge(\<L1\>, \<M1\>)","",false,false,[<"L",list(arb(0,[int(-20,20),str()]),1,5)>,<"M",same("L")>],[<"L1","sort(\<L\>)">,<"M1","sort(\<M\>)">],void(),"")),tvQuestion("Test/Libraries/List/merge","2",valueOfExpr(),details(" ",["import List;"],"","","merge(\<L1\>, \<M1\>)","",false,false,[<"L",list(arb(0,[int(-20,20),str()]),1,5)>,<"M",same("L")>],[<"L1","sort(\<L\>)">,<"M1","sort(\<M\>)">,<"H","merge(\<L1\>, \<M1\>)">],void(),"\<H\>")),tvQuestion("Test/Libraries/List/merge","3",valueOfExpr(),details(" ",["import List;","import String;"],"","","merge(\<L1\>, \<M1\>, ",") == \<H\>",false,true,[<"L",list(str(),1,5)>,<"M",same("L")>],[<"L1","sort(\<L\>,bool(str x, str y){return size(x) \> size(y);})">,<"M1","sort(\<M\>,bool(str x, str y){return size(x) \> size(y);})">,<"H","merge(\<L1\>, \<M1\>, bool(str x, str y){return size(x) \> size(y);})">],void(),"\<H\>"))]),"Test/Libraries/lang/csv":concept("Test/Libraries/lang/csv",[],[],{},[]),"Test/Libraries/List/getOneFrom":concept("Test/Libraries/List/getOneFrom",[],[],{},[tvQuestion("Test/Libraries/List/getOneFrom","1",typeOfExpr(),details(" ",["import List;"],"","","getOneFrom(\<L\>)","",false,false,[<"L",list(arb(0,[int(-20,20),str()]),1,6)>],[<"H","getOneFrom(\<L\>)">],void(),"\<H\>"))]),"Test":concept("Test",["Unkown or ambiguous concept in toc: XXX","non-existing detail NotThere"],["Cat2"],{},[tvQuestion("Test","1",typeOfExpr(),details(" ",["import List;"],"","","permutations(\<L\>)","",false,false,[<"L",list(arb(0,[int(-20,20),str()]),1,5)>],[],void(),"")),tvQuestion("Test","2",valueOfExpr(),details(" ",["import List;","import Set;"],"","","size(permutations(\<L\>)) == ","",false,true,[<"L",list(arb(0,[int(-20,20),str()]),1,5)>],[<"H","size(permutations(\<L\>))">],void(),"\<H\>")),tvQuestion("Test","3",valueOfExpr(),details(" ",["import List;"],"","","permutations(\<L\>) == ","",false,true,[<"L",list(arb(0,[int(-20,20),str()]),0,3)>],[<"H","permutations(\<L\>)">],void(),"\<H\>")),tvQuestion("Test","4",valueOfExpr(),details(" Fill in the missing operator.\n",[],"","","\<A\> "," \<B\> == \<C\>",false,true,[<"B",arb(0,[int(0,100),str()])>,<"A",list(same("B"),1,5)>],[<"C","\<A\> + \<B\>">],void(),"Use +.")),tvQuestion("Test","5",typeOfExpr(),details(" ",[],"","","\<A:set[arb]\> \> \<B:same[A]\>","",false,false,[<"A",set(arb(0,[bool(),int(-20,20),real(-20,20),num(-20,20),str(),\loc(),datetime()]),1,5)>,<"B",same("A")>],[],void(),"")),tvQuestion("Test","6",valueOfExpr(),details(" ",[],"","","2 * \<A:int\>","",false,false,[<"A",int(-20,20)>],[],void(),"")),tvQuestion("Test","7",typeOfExpr(),details(" ",[],"","","\<A:set[arb[int,str,real]]\>","",false,false,[<"A",set(arb(0,[int(-20,20),str(),real(-20,20)]),1,5)>],[],void(),""))]),"Test/Libraries/List/upTill":concept("Test/Libraries/List/upTill",[],[],{},[tvQuestion("Test/Libraries/List/upTill","1",typeOfExpr(),details(" ",["import List;"],"","","upTill(\<N\>)","",false,false,[<"N",int(2,5)>],[],void(),"")),tvQuestion("Test/Libraries/List/upTill","2",valueOfExpr(),details(" ",["import List;"],"","","upTill(\<N\>) == ","",false,true,[<"N",int(2,5)>],[<"H","upTill(\<N\>)">],void(),"\<H\>")),tvQuestion("Test/Libraries/List/upTill","3",valueOfExpr(),details(" ",["import List;"],"","","size(upTill(\<N\>)) == ","",false,true,[<"N",int(2,5)>],[<"H","size(upTill(\<N\>))">],void(),"\<H\>"))]),"Test/Libraries/List/drop":concept("Test/Libraries/List/drop",[],[],{},[choiceQuestion("Test/Libraries/List/drop","1","  Dropping \<code\>\<i\>n\</i\>\</code\> elements from a list returns a list with\n",[good("n elements less than the original list."),bad("1 element less that the original list."),bad("n elements."),bad("n-1 elements."),bad("n-1 elements less than the original list.")]),tvQuestion("Test/Libraries/List/drop","2",typeOfExpr(),details(" ",["import List;"],"","","drop(\<N\>, \<L\>)","",false,false,[<"L",list(arb(0,[bool(),int(-20,20),str()]),4,6)>,<"N",int(0,3)>],[<"H","drop(\<N\>, \<L\>)">],void(),"\<H\>")),tvQuestion("Test/Libraries/List/drop","3",valueOfExpr(),details(" ",["import List;"],"","","drop(\<N\>, \<L\>) == ","",false,true,[<"L",list(arb(0,[bool(),int(-20,20),str()]),4,6)>,<"N",int(0,3)>],[<"H","drop(\<N\>, \<L\>)">],void(),"\<H\>"))]),"Test/Libraries/List/permutations":concept("Test/Libraries/List/permutations",[],[],{},[choiceQuestion("Test/Libraries/List/permutations","1","  How many permutations has a list of N elements:\n",[good("1 x 2 x ... x N."),good("N x (N-1) x ... x 2 x 1."),good("N!"),bad("1 + 2 + ... + N."),bad("1 + 2 + ... + N-1.")]),tvQuestion("Test/Libraries/List/permutations","2",typeOfExpr(),details(" ",["import List;"],"","","permutations(\<L\>)","",false,false,[<"L",list(arb(0,[int(-20,20),str()]),1,5)>],[],void(),"")),tvQuestion("Test/Libraries/List/permutations","3",valueOfExpr(),details(" ",["import List;","import Set;"],"","","size(permutations(\<L\>)) == ","",false,true,[<"L",list(arb(0,[int(-20,20),str()]),1,5)>],[<"H","size(permutations(\<L\>))">],void(),"\<H\>")),tvQuestion("Test/Libraries/List/permutations","4",valueOfExpr(),details(" ",["import List;"],"","","permutations(\<L\>) == ","",false,true,[<"L",list(arb(0,[int(-20,20),str()]),0,3)>],[<"H","permutations(\<L\>)">],void(),"\<H\>"))]),"Test/Libraries/List/takeOneFrom":concept("Test/Libraries/List/takeOneFrom",[],[],{},[tvQuestion("Test/Libraries/List/takeOneFrom","1",typeOfExpr(),details(" ",["import List;"],"","","takeOneFrom(\<L\>)","",false,false,[<"L",list(arb(0,[int(-20,20),str()]),1,6)>],[],void(),""))]),"Test/Libraries/List/toString":concept("Test/Libraries/List/toString",[],[],{},[tvQuestion("Test/Libraries/List/toString","1",typeOfExpr(),details(" ",["import List;"],"","","toString(\<L\>)","",false,false,[<"L",list(int(-20,20),1,5)>],[],void(),"")),tvQuestion("Test/Libraries/List/toString","2",valueOfExpr(),details(" ",["import List;"],"","","toString(\<L\>) == ","",false,true,[<"L",list(int(-20,20),1,5)>],[<"H","toString(\<L\>)">],void(),"\<H\>"))]),"Test/ScreenTest/Simple":concept("Test/ScreenTest/Simple",[],[],{},[]),"Test/BBB":concept("Test/BBB",[],["Cat1"],{},[]),"Test/Libraries/List/zip":concept("Test/Libraries/List/zip",[],[],{},[tvQuestion("Test/Libraries/List/zip","1",valueOfExpr(),details(" ",["import List;"],"","","zip(\<L\>, \<M\>) == ","",false,true,[<"L",list(int(-20,20),4,4)>,<"M",list(int(-20,20),4,4)>],[<"Z","zip(\<L\>,\<M\>)">],void(),"\<Z\>"))]),"Test/Libraries/List/toRel":concept("Test/Libraries/List/toRel",[],[],{},[tvQuestion("Test/Libraries/List/toRel","1",typeOfExpr(),details(" ",["import List;"],"","","toRel(\<L\>)","",false,false,[<"L",list(arb(0,[int(-20,20),str()]),4,4)>],[],void(),"")),tvQuestion("Test/Libraries/List/toRel","2",valueOfExpr(),details(" ",["import List;"],"","","toRel(\<L\>) == ","",false,true,[<"L",list(arb(0,[int(-20,20),str()]),4,4)>],[<"H","toRel(\<L\>)">],void(),"\<H\>"))]),"Test/Libraries/List/head":concept("Test/Libraries/List/head",[],[],{},[tvQuestion("Test/Libraries/List/head","1",typeOfExpr(),details(" ",["import List;"],"","","head(\<L\>)","",false,false,[<"L",list(arb(0,[int(-20,20),str()]),1,6)>],[],void(),"")),tvQuestion("Test/Libraries/List/head","2",valueOfExpr(),details(" ",["import List;"],"","","head(\<L\>) == ","",false,true,[<"L",list(arb(0,[int(-20,20),str()]),1,6)>],[<"H","head(\<L\>)">],void(),"\<H\>"))]),"Test/AAA/AAA3":concept("Test/AAA/AAA3",[],[],{},[]),"Test/AAA/AAA2":concept("Test/AAA/AAA2",[],[],{},[]),"Test/Libraries/List/split":concept("Test/Libraries/List/split",[],[],{},[tvQuestion("Test/Libraries/List/split","1",typeOfExpr(),details(" ",["import List;"],"","","split(\<L\>)","",false,false,[<"L",list(arb(0,[int(-20,20),str()]),1,5)>],[],void(),"")),tvQuestion("Test/Libraries/List/split","2",valueOfExpr(),details(" ",["import List;"],"","","split(\<L\>) == ","",false,true,[<"L",list(arb(0,[int(-20,20),str()]),1,5)>],[<"H","split(\<L\>)">],void(),"\<H\>"))]),"Test/AAA/AAA1":concept("Test/AAA/AAA1",[],[],{},[]),"Test/BBB/BBB3":concept("Test/BBB/BBB3",[],[],{},[]),"Test/BBB/BBB2":concept("Test/BBB/BBB2",[],[],{},[]),"Test/BBB/BBB1":concept("Test/BBB/BBB1",[],[],{},[]),"Test/Libraries/lang/csv/IO/writeCSV":concept("Test/Libraries/lang/csv/IO/writeCSV",["PathNotFound(|std:///Rascal/Libraries/lang/csv/ex1a.csv|): L = |std:///Rascal/Libraries/lang/csv/ex1a.csv|, File Rascal/Libraries/lang/csv/ex1a.csv.","PathNotFound(|std:///Rascal/Libraries/lang/csv/ex1b.csv|): L = |std:///Rascal/Libraries/lang/csv/ex1b.csv|, File Rascal/Libraries/lang/csv/ex1b.csv."],[],{},[]),"Test/Libraries/List/slice":concept("Test/Libraries/List/slice",[],[],{},[choiceQuestion("Test/Libraries/List/slice","1","  Computing \<code\>slice(L, B, N)\</code\> returns a list with:\n",[good("N elements."),bad("B elements."),bad("B + N elements."),bad("N - 1 elements."),bad("B - 1 elements.")]),tvQuestion("Test/Libraries/List/slice","2",typeOfExpr(),details(" ",["import List;"],"","","slice(\<L\>,\<B\>,\<E\>)","",false,false,[<"L",list(arb(0,[int(-20,20),str()]),3,5)>,<"B",int(0,2)>,<"E",int(2,5)>],[],void(),"")),tvQuestion("Test/Libraries/List/slice","3",valueOfExpr(),details(" ",["import List;"],"","","slice(\<L\>,\<B\>,\<E\>) == ","",false,true,[<"L",list(arb(0,[int(-20,20),str()]),3,5)>,<"B",int(0,2)>,<"E",int(2,5)>],[<"H","slice(\<L\>,\<B\>,\<E\>)">],void(),"\<H\>"))]),"Test/Libraries/List/toMapUnique":concept("Test/Libraries/List/toMapUnique",[],[],{},[tvQuestion("Test/Libraries/List/toMapUnique","1",typeOfExpr(),details(" ",["import List;","import Set;"],"","","toMapUnique(\<P\>)","",false,false,[<"K",set(int(-20,20),6,6)>,<"V",list(int(-20,20),6,6)>],[<"KL","toList(\<K\>)">,<"P","zip(\<KL\>, \<V\>)">],void(),"")),tvQuestion("Test/Libraries/List/toMapUnique","2",valueOfExpr(),details(" ",["import List;","import Set;"],"","","toMapUnique(\<P\>) == ","",false,true,[<"K",set(int(-20,20),6,6)>,<"V",list(int(-20,20),6,6)>],[<"KL","toList(\<K\>)">,<"P","zip(\<KL\>, \<V\>)">,<"H","toMapUnique(\<P\>)">],void(),"\<H\>"))]),"Test/Libraries/List":concept("Test/Libraries/List",[],[],{},[]),"Test/Libraries/List/headTail":concept("Test/Libraries/List/headTail",[],[],{},[tvQuestion("Test/Libraries/List/headTail","1",typeOfExpr(),details(" ",["import List;"],"","","headTail(\<L\>)","",false,false,[<"L",list(arb(0,[int(-20,20),str()]),1,5)>],[],void(),"")),tvQuestion("Test/Libraries/List/headTail","2",valueOfExpr(),details(" ",["import List;"],"","","headTail(\<L\>) == ","",false,true,[<"L",list(arb(0,[int(-20,20),str()]),1,5)>],[<"H","headTail(\<L\>)">],void(),"\<H\>"))]),"Test/Libraries/List/tail":concept("Test/Libraries/List/tail",[],[],{},[choiceQuestion("Test/Libraries/List/tail","1","  Computing \<code\>tail(L, M)\</code\> of a list with \<code\>\<i\>N\</i\>\</code\> (\<code\>\<i\>N\</i\>\</code\> \> \<code\>\<i\>M\</i\>\</code\>) elements returns a list with\n",[good("M elements."),bad("N-M elements."),bad("N elements."),bad("N * M elements.")]),tvQuestion("Test/Libraries/List/tail","2",typeOfExpr(),details(" ",["import List;"],"","","tail(\<L\>, \<N\>)","",false,false,[<"L",list(arb(0,[bool(),int(-20,20),str()]),4,6)>,<"N",int(0,3)>],[],void(),"")),tvQuestion("Test/Libraries/List/tail","3",valueOfExpr(),details(" ",["import List;"],"","","tail(\<L\>,\<N\>) == ","",false,true,[<"L",list(arb(0,[bool(),int(-20,20),str()]),4,6)>,<"N",int(0,3)>],[<"H","tail(\<L\>,\<N\>)">],void(),"\<H\>"))]),"Test/Libraries/List/insertAt":concept("Test/Libraries/List/insertAt",[],[],{},[choiceQuestion("Test/Libraries/List/insertAt","1","  After inserting an element in a list with \<code\>\<i\>N\</i\>\</code\> elements, the new list has\n",[good("N+1 elements."),bad("N elements."),bad("N-1 elements."),bad("a length that depends on the inserted element.")]),tvQuestion("Test/Libraries/List/insertAt","2",typeOfExpr(),details(" ",["import List;"],"","","insertAt(\<L\>, \<I\>, \<E\>)","",false,false,[<"E",arb(0,[int(-20,20),str()])>,<"L",list(same("E"),4,6)>,<"I",int(0,3)>],[],void(),"")),tvQuestion("Test/Libraries/List/insertAt","3",valueOfExpr(),details(" ",["import List;"],"","","insertAt(\<L\>, \<I\>, \<E\>) == ","",false,true,[<"E",arb(0,[int(-20,20),str()])>,<"L",list(same("E"),4,6)>,<"I",int(0,3)>],[<"H","insertAt(\<L\>, \<I\>, \<E\>)">],void(),"\<H\>"))]),"Test/Libraries/List/domain":concept("Test/Libraries/List/domain",[],[],{},[choiceQuestion("Test/Libraries/List/domain","1","  The number of elements in the domain of a list is:\n",[good("Equal to the number of elements in the list."),bad("Depends on the number of repeated elements in the list."),bad("One less than the number of elements in the list."),bad("One larger than the number of elements in the list.")]),tvQuestion("Test/Libraries/List/domain","2",typeOfExpr(),details(" ",["import List;"],"","","domain(\<L\>)","",false,false,[<"L",list(arb(0,[int(-20,20),str()]),3,5)>],[],void(),"")),tvQuestion("Test/Libraries/List/domain","3",valueOfExpr(),details(" ",["import List;"],"","","domain(\<L\>) == ","",false,true,[<"L",list(arb(0,[int(-20,20),str()]),0,5)>],[<"H","domain(\<L\>)">],void(),"\<H\>"))]),"Test/Cat1/Cat13":concept("Test/Cat1/Cat13",[],[],{},[]),"Test/Libraries/List/dup":concept("Test/Libraries/List/dup",[],[],{},[tvQuestion("Test/Libraries/List/dup","1",typeOfExpr(),details(" ",["import List;"],"","","dup(\<L\>)","",false,false,[<"L",list(arb(0,[bool(),int(-20,20),str()]),4,6)>],[<"H","dup(\<L\>)">],void(),"\<H\>")),tvQuestion("Test/Libraries/List/dup","2",valueOfExpr(),details(" ",["import List;"],"","","dup(\<L1\>) == ","",false,true,[<"L",list(arb(0,[bool(),int(-20,20),str()]),4,6)>,<"I",int(0,3)>,<"J",int(0,3)>],[<"L1","[\<L\>[\<I\>], \<L\>[\<J\>], *\<L\>, \<L\>[\<J\>], \<L\>[\<I\>]]">,<"H","dup(\<L1\>)">],void(),"\<H\>"))]),"Test/Cat1/Cat12":concept("Test/Cat1/Cat12",[],[],{},[])),["AAA","AAA1","AAA2","AAA3","BBB","BBB1","BBB2","BBB3","Bla","Bla1","Bla2","Bla3","Bla4","Cat1","Cat11","Cat12","Cat13","Cat2","Cat21","Cat22","DOM","Exam","IO","Libraries","LinkBreak","List","ScreenTest","Simple","T20111114","T20111128","Test","csv","delete","distribution","domain","drop","dup","generate","getOneFrom","head","headTail","index","indexOf","insertAt","intercalate","isEmpty","lang","last","lastIndexOf","mapper","max","merge","min","mix","permutations","pop","prefix","push","readCSV","reducer","reverse","size","slice","sort","split","sum","tail","take","takeOneFrom","takeWhile","toMap","toMapUnique","toRel","toSet","toString","top","unzip","upTill","util","writeCSV","xml","zip"])