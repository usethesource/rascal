<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
  <html xmlns="http://www.w3.org/1999/xhtml">

<!---- DO NOT EDIT: HTML generated by CourseCompiler ---->


<head>
<title>Recipes/Common/CallAnalysis</title>

<meta name="description" content="Recipes/Common/CallAnalysis:  Analyzing the call structure of an application.">

<meta name="keywords" content="Recipes/Common/CallAnalysis, Rascal, meta-programming, software analysis, software transformation">
<link type="text/css" rel="stylesheet" href="/prelude.css"/>
<link type="text/css" rel="stylesheet" href="/jquery.autocomplete.css"/>
<script type="text/javascript" src="/jquery-1.4.2.min.js"></script>
<script type="text/javascript" src="/jquery.colorbox-min.js"></script>
<script type="text/javascript" src="/jquery.cookie.js"></script>
<script type="text/javascript" src="/jquery.jstree.js"></script>
<script type="text/javascript" src="/jquery.autocomplete.js"></script>
<script type="text/javascript" src="/jquery.history.js"></script>
<script type="text/javascript" src="/globals.js"></script>
<script type="text/javascript" src="/prelude.js"></script>
<script type="text/javascript" src="/Recipes/course.js"></script>

</head>
<body>
<table id="container"><tr><td id="tdlogo"><a id="tutorAction" href="/index.html"><img id="leftIcon" height="40" width="40" src="/images/rascal-tutor-small.png"></a></td><td id="tdsearch">
<div id="searchBox">
  <form method="GET" id="searchForm" action="/search"> 
    <img id="searchIcon" height="20" width="20" src="/images/magnify.png">
    <input type="hidden" name="concept" value="Recipes/Common/CallAnalysis">
    <input type="text" id="searchField" name="term" autocomplete="off"><br />
    <div id="popups"></div>
  </form>
</div>
</td></tr><tr><td id="tdnav">
<a id="navPanePlaceHolder" href="/Recipes/navigate.html" >Navigation</a>
<script type="text/javascript"> var navigationPaneSource="/Recipes/navigate.html"; </script></td><td id="tdconcept">
<div id="conceptPane">

<div id="Name">
<span class="sectionHead">Name</span> <a href="/Recipes/Recipes.html">Recipes</a>/<a href="/Recipes/Common/Common.html">Common</a>/<a href="/Recipes/Common/CallAnalysis/CallAnalysis.html">CallAnalysis</a>
</div>

<div id="Synopsis">
<span class="sectionHead">Synopsis</span>  Analyzing the call structure of an application.

</div>





<div id="Description">
<span class="sectionHead">Description</span>  Suppose a mystery box ends up on your desk. When you open it, it contains a huge software system with several questions attached to it:
  <ul><li> How many procedure calls occur in this system?</li>
<li> How many procedures does it contains?</li>
<li> What are the entry points for this system, i.e., procedures that call others but are not called themselves?</li>
<li> What are the leaves of this application, i.e., procedures that are called but do not make any calls themselves?</li>
<li> Which procedures call each other indirectly?</li>
<li> Which procedures are called directly or indirectly from each entry point?</li>
<li> Which procedures are called from all entry points?</li>
</ul> Let's see how these questions can be answered using Rascal.

</div>


<div id="Examples">
<span class="sectionHead">Examples</span>  Consider the following call graph (a box represents a procedure and an arrow represents a call from one procedure to another procedure):
 <br/>
<br/>

 <img class="TutorImg" width="300px"  title="calls" alt="calls" src="/Recipes/Common/CallAnalysis/calls.png">
  <pre class="screen"><span class="prompt">rascal></span>import Set;
ok
<span class="prompt">rascal></span>import Relation;
ok
<span class="prompt">rascal></span>import analysis::graphs::Graph;
ok
</pre>  Rascal supports basic data types like integers and strings which are sufficient to formulate and answer the questions at hand. However, we
  can gain readability by introducing separately named types for the items we are describing. 
  First, we introduce therefore a new type <code>Proc</code> (an alias for strings) to denote procedures:
<pre class="screen"><span class="prompt">rascal></span>alias Proc = str;
ok
</pre>  Next, we have to represent the call relation as a Rascal datatype, and the relation is the most appropriate for it.
  As preparation, we also import the libraries <a href="/Rascal/Libraries/Prelude/Set/Set.html">Rascal:Set</a>, <a href="/Rascal/Libraries/Prelude/Relation/Relation.html">Rascal:Relation</a> and <a href="/Rascal/Libraries/analysis/graphs/Graph/Graph.html">Rascal:Graph</a> that will come in handy.
<pre class="screen"><span class="prompt">rascal></span>rel[Proc, Proc] Calls = {&lt;&quot;a&quot;, &quot;b&quot;&gt;, &lt;&quot;b&quot;, &quot;c&quot;&gt;, &lt;&quot;b&quot;, &quot;d&quot;&gt;, &lt;&quot;d&quot;, &quot;c&quot;&gt;, 
<span class="continuation">>>>>>>></span>                         &lt;"d", "e">, &lt;"f", "e">, &lt;"f", "g">, &lt;"g", "e">};
rel[Proc,Proc]: {
  &lt;"f","e">,
  &lt;"g","e">,
  &lt;"a","b">,
  &lt;"b","d">,
  &lt;"b","c">,
  &lt;"d","c">,
  &lt;"d","e">,
  &lt;"f","g">
}
</pre>  Now we are in a good position to start asking some questions.
 <br/>
<br/>

  <b>How many calls occur in this system?</b>
  We use the function <a href="/Rascal/Libraries/Prelude/Set/size/size.html">Rascal:Set/size</a> to determine the number of elements in a set or relation.
  Since each tuple in the <code>Calls</code> relation represents a call between procedures, the number of tuples is equal
  to the number of calls.
<pre class="screen"><span class="prompt">rascal></span>size(Calls);
int: 8
</pre>  <b>How many procedures occur in this system?</b> This question is more subtle, since a procedure may call (or be called) by
  several others and the number of tuples is therefore not indicative. What we need are the set of procedures that
  occur (as first or second element) in <i>any</i> tuple. This is precisely what the function <a href="/Rascal/Libraries/Prelude/Relation/carrier/carrier.html">Rascal:carrier</a> gives us:
<pre class="screen"><span class="prompt">rascal></span>carrier(Calls);
set[Proc]: {"a","b","c","d","e","f","g"}
</pre>  and computing the number of procedures is now easy:
<pre class="screen"><span class="prompt">rascal></span>size(carrier(Calls));
int: 7
</pre>  As an aside, functions <a href="/Rascal/Libraries/Prelude/Relation/domain/domain.html">Rascal:domain</a> and <a href="/Rascal/Libraries/Prelude/Relation/range/range.html">Rascal:range</a> do the same for the first, respectively, second element of the pairs in a relation:
<pre class="screen"><span class="prompt">rascal></span>domain(Calls);
set[Proc]: {"a","b","d","f","g"}
<span class="prompt">rascal></span>range(Calls);
set[Proc]: {"b","c","d","e","g"}
</pre>  <b>What are the entry points for this system?</b>
 <br/>
<br/>

  The next step in the analysis is to determine which entry points this application has, i.e., procedures which call others but are 
  not called themselves. Entry points are useful since they define the external interface of a system and may also be used as guidance to
  split a system in parts. The top of a relation contains those left-hand sides of tuples in a relation that do not occur in any 
  right-hand side. When a relation is viewed as a graph, its top corresponds to the root nodes of that graph. Similarly, the bottom of a 
  relation corresponds to the leaf nodes of the graph. See the section called  <a href="/Rascal/Libraries/analysis/graphs/Graph/Graph.html">Rascal:Graph</a> for more details. Using this knowledge, the entry
  points can be computed by determining the top of the Calls relation:
<pre class="screen"><span class="prompt">rascal></span>top(Calls);
set[Proc]: {"a","f"}
</pre> <b>What are the leaves of this application?</b>
 <br/>
<br/>

  In a similar spirit, we can determine the leaves of this application, i.e., procedures that are being called but do not make any calls
  themselves:
<pre class="screen"><span class="prompt">rascal></span>bottom(Calls);
set[Proc]: {"c","e"}
</pre>  <b>Which procedures call each other indirectly?</b>
 <br/>
<br/>

  We can also determine the indirect calls between procedures, by taking the transitive closure of the Calls relation, written as <code>Calls+</code>. 
  Observe that the transitive closure will contain both the direct and the indirect calls.
<pre class="screen"><span class="prompt">rascal></span>closureCalls = Calls+;
rel[Proc,Proc]: {
  &lt;"f","e">,
  &lt;"g","e">,
  &lt;"a","b">,
  &lt;"a","c">,
  &lt;"b","c">,
  &lt;"d","c">,
  &lt;"d","e">,
  &lt;"f","g">,
  &lt;"a","d">,
  &lt;"b","e">,
  &lt;"b","d">,
  &lt;"a","e">
}
</pre>  <b>Which procedures are called directly or indirectly from each entry point?</b>
 <br/>
<br/>

  We now know the entry points for this application ("a" and "f") and the indirect call relations. Combining this information, 
  we can determine which procedures are called from each entry point. This is done by indexing closureCalls with appropriate procedure name.
  The index operator yields all right-hand sides of tuples that have a given value as left-hand side. This gives the following:
<pre class="screen"><span class="prompt">rascal></span>calledFromA = closureCalls[&quot;a&quot;];
set[Proc]: {"b","c","d","e"}
<span class="prompt">rascal></span>calledFromF = closureCalls[&quot;f&quot;];
set[Proc]: {"e","g"}
</pre>  <b>Which procedures are called from all entry points?</b>
 <br/>
<br/>

  Finally, we can determine which procedures are called from both entry points by taking the intersection of the two sets 
  <code>calledFromA</code> and <code>calledFromF</code>:
<pre class="screen"><span class="prompt">rascal></span>calledFromA &amp; calledFromF;
set[Proc]: {"e"}
</pre>  or if your prefer to write all of the above as a one-liner using a <a href="/Rascal/Expressions/Reducer/Reducer.html">Rascal:Reducer</a> expression:
<pre class="screen"><span class="prompt">rascal></span>(carrier(Calls) | it &amp; (Calls+)[p] | p &lt;- top(Calls));
set[Proc]: {"e"}
</pre> The reducer is initialized with  all procedures (<code>carrier(Calls)</code>) and iterates over all entry points (<code>p &lt;- top(Calls)</code>).
 At each iteration the current value of the reducer (<code>it</code>) is intersected (<code>&amp;</code>) with the procedures called directly or indirectly
 from that entry point (<code>(Calls+)[p]</code>).

</div>


<div id="Benefits">
<span class="sectionHead">Benefits</span>  <ul><li> In small examples, the above results can be easily obtained by a visual inspection of the call graph. Such a visual inspection does <i>not</i> scale very well to large graphs and this makes the above form of analysis particularly suited for studying large systems.
</li>
</ul>
</div>


<div id="Pitfalls">
<span class="sectionHead">Pitfalls</span>  <ul><li> We discuss call analysis in a, intentionally, simplistic fashion that does not take into account how the call relation   is extracted from actual source code.
   The above principles are, however, applicable to real cases as well.
</li>
</ul>
</div>


<a id="tutorAction" href="/index.html"><img id="leftIcon" height="40" width="40" src="/images/rascal-tutor-small.png"></a><div id="editMenu">[<a id="editAction" href="/edit?concept=Recipes/Common/CallAnalysis&new=false"><b>Edit</b></a>] | 
               [<a id="newAction" href="/edit?concept=Recipes/Common/CallAnalysis&new=true"><b>New Subconcept</b></a>] |
               [<a id="compileAction" href="/compile?name=Recipes"><b>Recompile Course</b></a>] |
               [<a id="warnAction" href="/Recipes/warnings.html"><b>Warnings</b></a>]</div>
<span class="editMenuFooter">Is this page unclear, or have you spotted an error? Please add a comment below and help us to improve it. For all other questions and remarks, visit <a href="http://ask.rascal-mpl.org">ask.rascal-mpl.org</a>. </span>
</div>
</td></tr></table>
</body>
</html>