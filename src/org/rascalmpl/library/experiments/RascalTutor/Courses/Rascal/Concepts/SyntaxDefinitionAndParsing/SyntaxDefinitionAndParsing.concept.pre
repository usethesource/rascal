concept("SyntaxDefinitionAndParsing",|cwd:///src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Concepts/SyntaxDefinitionAndParsing/SyntaxDefinitionAndParsing.concept|,[],{},{"Concepts/PatternMatching"},"","","","",{},"All source code analysis projects need to extract information directly from the source code. \nThere are two main approaches to this:\n\n\<ul\>\n\<li\> \<i\>Lexical information\</i\>: Use regular expressions to extract useful, but somewhat superficial, flat, information.     This can be achieved using regular expression patterns.\</li\>\n\<li\> \<i\>Structured information\</i\>: Use syntax analysis to extract the complete, nested, structure of the source code     in the form of a syntax tree.\</li\>\n\n\</ul\>\nIn Rascal, we reuse the Syntax Definition Formalism (SDF) and its tooling. \nSee \<a href=\"http://www.meta-environment.org/Meta-Environment/Documentation\"\>http://www.meta-environment.org/Meta-Environment/Documentation\</a\> for tutorials and manuals for SDF.\n\nSDF modules define grammars and these modules can be imported in a Rascal module. \nThese grammar rules can be applied in writing concrete patterns to match parts of parsed source code. \nHere is an example of the same pattern we saw in \<a href=\"/show?concept=Concepts/PatternMatching\"\>Concepts/PatternMatching\</a\>, but now in concrete form:\n\n\<pre class=\"listing\"\>while &lt;Exp\> do &lt;Stats\> od\n\</pre\>Importing an SDF module has the following effects:\n\n\<ul\>\n\<li\>  All non-terminals (sorts in SDF jargon) that are used in the imported grammar are implicitly      declared as Rascal types. For each SDF sort S also composite symbols like \<code\>S*\</code\>, \<code\>{S \",\"}+\</code\> also become      available as type. This makes it possible to handle parse trees and parse tree fragments as fully typed      values and assign them to variables, store them in larger datastructures or pass them as arguments      to functions and use them in pattern matching.\</li\>\n\<li\>  For all \<i\>start symbols\</i\> of the grammar \<i\>parse functions\</i\> are implicitly declared that can parse source files      according to a specific start symbol.\</li\>\n\<li\>  Concrete syntax patterns for that specific grammar can be used.\</li\>\n\<li\>  Concrete syntax constructors can be used that allow the construction of new parse trees.\</li\>\n\n\</ul\>\n","The following example parses a Java compilation unit from a text file and counts the number of method declarations:\n\n\<pre class=\"listing\"\>module Count\nimport languages::java::syntax::Java;\nimport ParseTree;\n\npublic int countMethods(loc file){\n  int n = 0;\n  for(/MethodDeclaration md &lt;- parse(#CompilationUnit, file))\n      n += 1;\n  return n;\n}\n\</pre\>First observe that importing the Java grammar has as effect that non-terminals like \<code\>MethodDeclaration\</code\> and \n\<code\>CompilationUnit\</code\> become available as type in the Rascal program.\n\nThe implicitly declared function \<code\>parse\</code\> takes a reified type (\<code\>#CompilationUnit\</code\>) and a location \nas arguments and parses the contents of the location according to the given non-terminal. \nNext, a match for embedded \<code\>MethodDeclaration\</code\>s is done in the enumerator of the for statement. \n","","This example ignores many potential error conditions but does illustrate some of Rascal\'\\s syntax and \nparsing features.\n",[])