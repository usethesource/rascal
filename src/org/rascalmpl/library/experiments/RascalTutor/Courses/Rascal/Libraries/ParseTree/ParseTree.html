<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
  <html xmlns="http://www.w3.org/1999/xhtml">

<!---- DO NOT EDIT: HTML generated by CourseCompiler ---->


<head>
<title>Rascal/Libraries/ParseTree</title>

<meta name="description" content="Rascal/Libraries/ParseTree:  Functions on parse trees.">

<meta name="keywords" content="Rascal/Libraries/ParseTree, Rascal, meta-programming, software analysis, software transformation">
<link type="text/css" rel="stylesheet" href="/Courses/prelude.css"/>
<link type="text/css" rel="stylesheet" href="/Courses/jquery.autocomplete.css"/>
<script type="text/javascript" src="/Courses/jquery-1.4.2.min.js"></script>
<script type="text/javascript" src="/Courses/jquery.colorbox-min.js"></script>
<script type="text/javascript" src="/Courses/jquery.cookie.js"></script>
<script type="text/javascript" src="/Courses/jquery.jstree.js"></script>
<script type="text/javascript" src="/Courses/jquery.autocomplete.js"></script>
<script type="text/javascript" src="/Courses/jquery.history.js"></script>
<script type="text/javascript" src="/Courses/globals.js"></script>
<script type="text/javascript" src="/Courses/prelude.js"></script>
<script type="text/javascript" src="/Courses/Rascal/course.js"></script>

</head>
<body>
<table id="container"><tr><td id="tdlogo"><a id="tutorAction" href="/Courses/index.html"><img id="leftIcon" height="40" width="40" src="/Courses/images/rascal-tutor-small.png"></a></td><td id="tdsearch">
<div id="searchBox">
  <form method="GET" id="searchForm" action="/search"> 
    <img id="searchIcon" height="20" width="20" src="/Courses/images/magnify.png">
    <input type="hidden" name="concept" value="Rascal/Libraries/ParseTree">
    <input type="text" id="searchField" name="term" autocomplete="off"><br />
    <div id="popups"></div>
  </form>
</div>
         </td></tr><tr><td id="tdnav">
<a id="navPanePlaceHolder" href="/Courses/Rascal/navigate.html" >Navigation</a>
<script type="text/javascript"> var navigationPaneSource="/Courses/Rascal/navigate.html"; </script></td><td id="tdconcept">
<div id="conceptPane">

<div id="Name">
<span class="sectionHead">Name</span> <a href="/Courses/Rascal/Rascal.html">Rascal</a>/<a href="/Courses/Rascal/Libraries/Libraries.html">Libraries</a>/<a href="/Courses/Rascal/Libraries/ParseTree/ParseTree.html">ParseTree</a>
</div>

<div id="Synopsis">
<span class="sectionHead">Synopsis</span>  Functions on parse trees.

</div>

	                       
<div id="Syntax">
<span class="sectionHead">Syntax</span>  <code>import ParseTree;</code>

</div>

                           
                           
<div id="Details">
<span class="sectionHead">Details</span> <a href="/Courses/Rascal/Libraries/ParseTree/implode/implode.html">implode</a> &#032 <a href="/Courses/Rascal/Libraries/ParseTree/parse/parse.html">parse</a> &#032 <a href="/Courses/Rascal/Libraries/ParseTree/unparse/unparse.html">unparse</a> &#032 
</div>

<div id="Description">
<span class="sectionHead">Description</span>  A <i>concrete syntax tree</i> or <a href="http://en.wikipedia.org/wiki/Parse_tree">parse tree<img src="/Courses/images/www-icon.png" with="20" height="20"></a> is an ordered, rooted tree that 
 represents the syntactic structure of a string according to some formal grammar. In a parse tree, the interior nodes are labeled by non-terminals of the grammar, while the leaf nodes are labeled by terminals of the grammar. 
 <br/>
<br/>

 <code>Tree</code> is the universal parse tree data type in Rascal and can be used to represent parse trees for any language. 
 <ul><li> <code>Tree</code> is a subtype of the type <a href="/Courses/Rascal/Expressions/Values/Node/Node.html">Node</a>.</li>
<li> All <a href="/Courses/Rascal/Declarations/SyntaxDefinition/SyntaxDefinition.html">SyntaxDefinition</a> types (non-terminals) are sub-types of <code>Tree</code></li>
<li> All <a href="/Courses/Rascal/Expressions/ConcreteSyntax/ConcreteSyntax.html">ConcreteSyntax</a> expressions produce parse trees the types of which are non-terminals</li>
<li> Trees can be annotated in various ways, see <a href="/Courses/Rascal/Concepts/IDEConstruction/IDEConstruction.html">IDEConstruction</a> features. Most importantly the <code>\loc</code> annotation always points to the source location of any (sub) parse tree.</li>
</ul> Parse trees are usually analyzed and constructed using <a href="/Courses/Rascal/Expressions/ConcreteSyntax/ConcreteSyntax.html">ConcreteSyntax</a> expressions and patterns.
 <br/>
<br/>

 <i>Advanced users</i> may want to create tools that analyze any parse tree, regardless of the <a href="/Courses/Rascal/Declarations/SyntaxDefinition/SyntaxDefinition.html">SyntaxDefinition</a> that generated it, you can manipulate them on the abstract level.
 <br/>
<br/>

 Below is the full definition of <code>Tree</code> and <code>Production</code> and <code>Symbol</code>. A parse tree is a nested tree structure of type <code>Tree</code>. 
 <ul><li> Most internal nodes are applications (<code>appl</code>) of a <code>Production</code> to a list of children <code>Tree</code> nodes. <code>Production</code> is the abstract representation of a <a href="/Courses/Rascal/Declarations/SyntaxDefinition/SyntaxDefinition.html">SyntaxDefinition</a> rule, which consists of a definition of an alternative for a <code>Symbol</code> by a list of <code>Symbols</code>.</li>
<li> The leaves of a parse tree are always characters (<code>char</code>), which have an integer index in the UTF8 table. 
</li>
<li> Some internal nodes encode ambiguity (<code>amb</code>) by pointing to a set of  alternative <code>Tree</code> nodes.
</li>
</ul> The <code>Production</code> and <code>Symbol</code> types are an abstract notation for rules in <a href="/Courses/Rascal/Declarations/SyntaxDefinition/SyntaxDefinition.html">SyntaxDefinition</a>s, while the <code>Tree</code> type is the actual notation
 for parse trees. 
 <br/>
<br/>

 Parse trees are called parse forests when they contain <code>amb</code> nodes.
 <br/>
<br/>

 You can analyze and manipulate parse trees in three ways:
 <ul><li> Directly on the <code>Tree</code> level, just like any other <a href="/Courses/Rascal/Declarations/AlgebraicDataType/AlgebraicDataType.html">AlgebraicDataType</a></li>
<li> Using <a href="/Courses/Rascal/Expressions/ConcreteSyntax/ConcreteSyntax.html">ConcreteSyntax</a></li>
<li> Using <a href="/Courses/Rascal/Declarations/SyntaxDefinition/Action/Action.html">Action</a>s</li>
</ul> The type of a parse tree is the symbol that it's production produces, i.e. <code>appl(prod(sort("A"),[],{}),[])</code> has type <code>A</code>. Ambiguity nodes 
 Each such a non-terminal type has <code>Tree</code> as its immediate super-type.
  <pre class="listing">module ParseTree

import Message;

@doc{These are the trees normally found after parsing}
data Tree 
  = appl(Production prod, list[Tree] args) 
  | cycle(Symbol symbol, int cycleLength) 
  | amb(set[Tree] alternatives)  
  | char(int character)
  ;
  
@doc{These trees constructors are used additionally in error trees}
data Tree 
  = error(Production prod, list[Tree] args, list[Tree] rest)
  | expected(Symbol symbol)
  | erroramb(set[Tree] alternatives)
  | errorcycle(Symbol symbol, int cycleLength)
  ;

@doc{
  Productions are the rules of a grammar, with a defined non-terminal, a list
  of terminal and non-terminal symbols and a possibly empty set of attributes.
}
data Production 
  = prod(Symbol def, list[Symbol] symbols, set[Attr] attributes) 
  | regular(Symbol def)
  ;

@doc{
  Attributes document additional semantics of a production rule. Neither tags nor
  brackets are processed by the parser generator. Rather downstream processors are
  activated by these. Associativity is a parser generator feature though. 
}
data Attr 
  = \assoc(Associativity \assoc)  
  | \tag(value \tag) 
  | \bracket() 
  ;

@doc{These are the kinds of associativity}
data Associativity 
  = \left() 
  | \right() 
  | \assoc() 
  | \non-assoc()
  ;

data CharRange = range(int begin, int end);

alias CharClass = list[CharRange];

@doc{The start symbol wraps any symbol to indicate it will occur at the top}
data Symbol = \start(Symbol symbol);

@doc{These symbols are the named non-terminals} 
data Symbol 
  = \sort(str name)  
  | \lex(str name) 
  | \layouts(str name) 
  | \keywords(str name)
  | \parameterized-sort(str name, list[Symbol] parameters)  
  | \parameter(str name)
  | \label(str name, Symbol symbol)
  ; 

@doc{These are the terminal symbols}
data Symbol 
  = \lit(str string) 
  | \cilit(str string)
  | \char-class(list[CharRange] ranges)
  ;
    
@doc{These are the regular expressions}
data Symbol
  = \empty()  
  | \opt(Symbol symbol)  
  | \iter(Symbol symbol)   
  | \iter-star(Symbol symbol)   
  | \iter-seps(Symbol symbol, list[Symbol] separators)   
  | \iter-star-seps(Symbol symbol, list[Symbol] separators) 
  | \alt(set[Symbol] alternatives)
  | \seq(list[Symbol] sequence)
  ;
  
@doc{The conditional wrapper adds conditions to the existance of an instance of a symbol}
data Symbol = \conditional(Symbol symbol, set[Condition] conditions);

@doc{Conditions on symbols give rise to disambiguation filters.}    
data Condition
  = \follow(Symbol symbol)
  | \not-follow(Symbol symbol)
  | \precede(Symbol symbol)
  | \not-precede(Symbol symbol)
  | \delete(Symbol symbol)
  | \at-column(int column) 
  | \begin-of-line()  
  | \end-of-line()  
  ;
         
@doc{provides access to the source location of a parse tree node}
anno loc Tree@\loc;

@doc{Parse the contents of a resource pointed to by the input parameter and return a parse tree.}
@javaClass{org.rascalmpl.library.ParseTree}
@reflect{uses information about syntax definitions at call site}
public java &amp;T&lt;:Tree parse(type[&amp;T&lt;:Tree] \begin, loc input);

@doc{Parse the contents of a resource pointed to by the input parameter and return a parse tree which can contain error nodes.}
@javaClass{org.rascalmpl.library.ParseTree}
@reflect{uses information about syntax definitions at call site}
public java &amp;T&lt;:Tree parseWithErrorTree(type[&amp;T&lt;:Tree] begin, loc input);

@doc{Parse a string and return a parse tree.}
@javaClass{org.rascalmpl.library.ParseTree}
@reflect{uses information about syntax definitions at call site}
public java &amp;T&lt;:Tree parse(type[&amp;T&lt;:Tree] begin, str input);

@doc{Parse a string and return a parse tree, which can contain error nodes.}
@javaClass{org.rascalmpl.library.ParseTree}
@reflect{uses information about syntax definitions at call site}
public java &amp;T&lt;:Tree parseWithErrorTree(type[&amp;T&lt;:Tree] begin, str input);

@doc{Parse a string and return a parse tree.}
@javaClass{org.rascalmpl.library.ParseTree}
@reflect{uses information about syntax definitions at call site}
public java &amp;T&lt;:Tree parse(type[&amp;T&lt;:Tree] begin, str input, loc origin);

@doc{Parse a string and return a parse tree, which can contain error nodes.}
@javaClass{org.rascalmpl.library.ParseTree}
@reflect{uses information about syntax definitions at call site}
public java &amp;T&lt;:Tree parseWithErrorTree(type[&amp;T&lt;:Tree] begin, str input, loc origin);

@doc{Yields the string of characters that form the leafs of the given parse tree.}
@javaClass{org.rascalmpl.library.ParseTree}
public java str unparse(Tree tree);

@doc{
Parsetree Implosion
===================

This function implodes a parsetree by simulataneously traversing the 
reified ADT and the parse tree. Meanwhile, an AST is constructed as follows:

- Literals, layout and empty (i.e. ()) nodes are skipped.

- Regular */+ lists are imploded to list[]s or set[]s depending on what is 
  expected in the ADT.

- Ambiguities are imploded to set[]s.

- If a tree's production has no label and a single AST (i.e. non-layout, non-literal) argument
  (for instance, and injection), the tree node is skipped, and implosion continues 
  with the lone argument. The same applies to bracket productions, even if they
  are labeled.

- If a tree's production has no label, but more than one argument, the tree is imploded 
  to a tuple (provided this conforms to the ADT).
  
  Example
  
    syntax IDTYPE = Id ":" Type;
    
    syntax Decls = decls: "declare" \{IDTYPE ","\}* ";";
    
  Hence, Decls will be imploded as:
    
    data Decls = decls(list[tuple[str,Type]]);
    
  (assuming Id is a lexical non-terminal).   

- Optionals are imploded to booleans if this is expected in the ADT.
  This also works for optional literals, as shown in the following
  example:
  
    syntax Formal = formal: "VAR"? \{Id ","\}+ ":" Type;
  
  The corresponding ADT could be:
  
    data Formal = formal(bool, list[str], Type);
    

- An optional is imploded to a list with zero or one argument, iff a list
  type is expected.

- If the argument of an optional tree has a production with no label, containing
  a single list, then this list is spliced into the optional list.
  
  Example:
  
    syntax Tag = "[" \{Modifier ","\}* "]";
    syntax Decl = decl: Tag? Signature Body;
  
  In this case, a Decl is imploded into the following ADT:
  
    data Decl = decl(list[Modifier], Signature, Body);  
  
- For trees with (cons-)labeled productions, the corresponding constructor
  in the ADT corresponding to the non-terminal of the production is found in
  order to make the AST.
  
  Typical example:
  
    syntax Exp = left add: Exp "+" Exp;
  
  Can be imploded into:
    data Exp = add(Exp, Exp);
  
- Unlabeled lexicals are imploded to str, int, real, bool depending on the expected type in
  the ADT. To implode lexical into types other than str, the PDB parse functions for 
  integers and doubles are used. Boolean lexicals should match "true" or "false". 
  NB: lexicals are imploded this way, even if they are ambiguous.

- If a lexical tree has a cons label, the tree imploded to a constructor with that name
  and a single string-valued argument containing the tree's yield.

IllegalArgument is thrown if during implosion a tree is encountered that cannot be
imploded to the expected type in the ADT. As explained above, this routine assumes the
ADT type names correspond to syntax non-terminal names, and constructor names correspond 
to production labels. Labels of production arguments do not have to match with labels
 in ADT constructors.

Finally, source location annotations are propagated as annotations on constructor ASTs. 
To access them, the user is required to explicitly declare a location annotation on all
ADTs used in implosion. In other words, for every ADT type T, add:

anno loc T@location;

}
@javaClass{org.rascalmpl.library.ParseTree}
public java &amp;T&lt;:node implode(type[&amp;T&lt;:node] t, Tree tree);

@doc{introduces a (error) message related to a certain sub-tree}
public anno Message Tree@message;

@doc{lists all (error) messages relevant for a certain sub-tree}
public anno set[Message] Tree@messages;

@doc{provides a documentation string for this parse tree node}
anno str Tree@doc;

@doc{provides a documentation string for certain locations}
anno map[loc,str] Tree@docs;

@doc{provides the target of a reference}
anno loc Tree@link;

@doc{provides multiple targets of a references}
anno set[loc] Tree@links;

@doc{result type for treeAt()}
public data TreeSearchResult[&amp;T&lt;:Tree] = treeFound(&amp;T tree) | treeNotFound();

@doc{selects the innermost Tree of type t which location encloses l}
public TreeSearchResult[&amp;T&lt;:Tree] treeAt(type[&amp;T&lt;:Tree] t, loc l, a:appl(_, _)) {
	if ((a@\loc)?, al := a@\loc, al.offset &lt;= l.offset, al.offset + al.length >= l.offset + l.length) {
		for (arg &lt;- a.args, r:treeFound(_) := treeAt(t, l, arg)) {
			return r;
		}
		
		if (&amp;T&lt;:Tree tree := a) {
			return treeFound(tree);
		}
	}
	return treeNotFound();
}

public default TreeSearchResult[&amp;T&lt;:Tree] treeAt(type[&amp;T&lt;:Tree] t, loc l, Tree root) = treeNotFound();

public bool sameType(label(_,Symbol s),Symbol t) = sameType(s,t);
public bool sameType(Symbol s,label(_,Symbol t)) = sameType(s,t);
public bool sameType(Symbol s,conditional(Symbol t,_)) = sameType(s,t);
public bool sameType(conditional(Symbol s,_), Symbol t) = sameType(s,t);
public bool sameType(Symbol s, s) = true;
public default bool sameType(Symbol s, Symbol t) = false;
</pre>
</div>

  	                       
  	                       
  	                       
<div id="Pitfalls">
<span class="sectionHead">Pitfalls</span>  For historical reasons the name of the annotation is "loc" and this interferes with the Rascal keyword <code>loc</code>
 for the type of <a href="/Courses/Rascal/Expressions/Values/Location/Location.html">Location</a>s.
 Therefore the annotation name has to be escaped as <code>\loc</code> when it is declared or used.

</div>

  	                       
<a id="tutorAction" href="/Courses/index.html"><img id="leftIcon" height="40" width="40" src="/Courses/images/rascal-tutor-small.png"></a><div id="editMenu">[<a id="editAction" href="/edit?concept=Rascal/Libraries/ParseTree&new=false"><b>Edit</b></a>] | 
               [<a id="newAction" href="/edit?concept=Rascal/Libraries/ParseTree&new=true"><b>New Subconcept</b></a>] |
               [<a id="compileAction" href="/compile?name=Rascal"><b>Recompile Course</b></a>] |
               [<a id="warnAction" href="/Courses/Rascal/warnings.html"><b>Warnings</b></a>]</div>

</div>
</td></tr></table>
</body>
</html>