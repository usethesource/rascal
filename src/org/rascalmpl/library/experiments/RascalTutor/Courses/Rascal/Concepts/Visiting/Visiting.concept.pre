concept("Visiting",|cwd:///src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Concepts/Visiting/Visiting.concept|,[],{},{"fail","insert","ColoredTrees"},"","","","",{},"Visiting the elements of a datastructure is one of the most common operations in our domain \nand the visitor design pattern is a solution known to every software engineer. \nGiven a tree-like datastructure we want to perform an operation on some (or all) nodes of the tree. The purpose of the visitor design pattern is to decouple the logistics of visiting each node from the actual operation on each node. In Rascal the logistics of visiting is completely automated.\n\nVisiting is achieved by way of visit expressions that resemble the switch statement. A visit expressions traverses an arbitrarily complex subject value and applies a number of cases to all its subtrees. \nAll the elements of the subject are visited and when one of the cases matches the statements associated \nwith that case are executed. These cases may:\n\n\<ul\>\n\<li\> cause some side effect, i.e., assign a value to local or global variables;\</li\>\n\<li\> execute an [\<a href=\"/show?concept=insert\"\>insert\</a\>] statement that replaces the current element;\</li\>\n\<li\> execute a [\<a href=\"/show?concept=fail\"\>fail\</a\>] statement that causes the match for the current case to fail (and undoing all side-effects due to the successful match itself and the execution of the statements so far).\<br/\>\n\<br/\>\nThe value of a visit expression is the original subject value with all replacements made as dictated by matching cases. The traversal order in a visit expressions can be explicitly defined by the programmer. \</li\>\n\n\</ul\>\n","An example of visiting is given in [\<a href=\"/show?concept=ColoredTrees\"\>ColoredTrees\</a\>].\n","","",[])