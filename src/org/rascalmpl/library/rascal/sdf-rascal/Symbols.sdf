module languages/rascal/syntax/Symbols

imports languages/rascal/syntax/Names
%% This is a modified clone of languages/sdf2/syntax/Regular, Character, Character-Class, and Sorts, and StrCon


exports
sorts StrCon StrChar

lexical syntax
  "\\n"                        -> StrChar {cons("newline")} 
  "\\t"                        -> StrChar                   
  "\\\""                       -> StrChar                   
  "\\\\"                       -> StrChar                   
  "\\" a:[0-9] b:[0-9] c:[0-9] -> StrChar                   
  ~[\0-\31\n\t\"\\]            -> StrChar                   
  [\"] chars:StrChar* [\"]     -> StrCon                    

sorts Symbol

sorts SingleQuotedStrCon SingleQuotedStrChar

lexical syntax
  "\\n"                                -> SingleQuotedStrChar  
  "\\t"                                -> SingleQuotedStrChar  
  "\\'"                                -> SingleQuotedStrChar  
  "\\\\"                               -> SingleQuotedStrChar  
  "\\" a:[0-9] b:[0-9] c:[0-9]         -> SingleQuotedStrChar  
  ~[\0-\31\n\t\'\\]                    -> SingleQuotedStrChar  
  [\'] chars:SingleQuotedStrChar* [\'] -> SingleQuotedStrCon   

context-free syntax
  "(" ")"                               -> Symbol {cons("Empty")}                  
  "(" head:Symbol tail:Symbol+ ")"      -> Symbol {cons("Sequence")}               
  symbol:Symbol "?"                     -> Symbol {cons("Optional")}               
  symbol:Symbol "+"                     -> Symbol {cons("Iter")}                   
  symbol:Symbol "*"                     -> Symbol {cons("IterStar")}               
  "{" symbol:Symbol sep:StrCon "}" "+"  -> Symbol {cons("IterSep")}                
  "{" symbol:Symbol sep:StrCon "}" "*"  -> Symbol {cons("IterStarSep")}            
  lhs:Symbol "|" rhs:Symbol             -> Symbol {right, cons("Alternative")}     
  charClass:CharClass                   -> Symbol {cons("CharacterClass")}         
  string:StrCon                         -> Symbol {cons("Literal")}                
  singelQuotedString:SingleQuotedStrCon -> Symbol {cons("CaseInsensitiveLiteral")}

context-free priorities
  {
    symbol:Symbol "?" -> Symbol {cons("Optional")}            
    symbol:Symbol "*" -> Symbol {cons("IterStar")}
    symbol:Symbol "+" -> Symbol {cons("Iter")}             
  } >
  lhs:Symbol "|" rhs:Symbol -> Symbol {right, cons("Alternative")}  

sorts Type

context-free priorities
   symbol:Symbol -> Type    {cons("Symbol")} >
   {
      name:Name                      -> Symbol  {cons("Sort")} 
      lhs:Symbol "|" rhs:Symbol -> Symbol {right, cons("Alternative")}
   } 


sorts CharClass CharRange CharRanges OptCharRanges

context-free syntax
  character:Character                      -> CharRange     {cons("Character")}                
  start:Character "-" end:Character        -> CharRange     {cons("Range")}                    
  range:CharRange                          -> CharRanges    {cons("Range")}                    
  lhs:CharRanges rhs:CharRanges            -> CharRanges    {cons("Concatenate"), right, memo} 
  "(" ranges:CharRanges ")"                -> CharRanges    {bracket, cons("Bracket")}                          
                                           -> OptCharRanges {cons("Absent")}                   
  ranges:CharRanges                        -> OptCharRanges {cons("Present")}                  
  "[" optionalCharRanges:OptCharRanges "]" -> CharClass     {cons("SimpleCharclass")}          
  "(" charClass:CharClass ")"                        -> CharClass     {bracket, cons("Bracket"), avoid}                   

context-free priorities
  "~" charClass:CharClass -> CharClass {cons("Complement")} >
  lhs:CharClass "/" rhs:CharClass -> CharClass {cons("Difference"), left, memo} >
  lhs:CharClass "/\\" rhs:CharClass -> CharClass {cons("Intersection"), left, memo} >
  lhs:CharClass "\\/" rhs:CharClass -> CharClass {cons("Union"), left}

exports
sorts Character NumChar ShortChar

lexical syntax
  [\\] number:[0-9]+                    -> NumChar    
  character:[a-zA-Z0-9]                 -> ShortChar  
  [\\] escape:~[\0-\31A-Za-mo-qsu-z0-9] -> ShortChar  

context-free syntax
  numChar:NumChar     -> Character {cons("Numeric")}    
  shortChar:ShortChar -> Character {cons("Short")}      
  "\\TOP"             -> Character {cons("Top")}        
  "\\EOF"             -> Character {cons("EOF")}        
  "\\BOT"             -> Character {cons("Bottom")}     
