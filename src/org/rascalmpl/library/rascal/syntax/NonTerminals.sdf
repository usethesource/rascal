module rascal/syntax/NonTerminals

imports rascal/syntax/Lexical

exports
sorts UnicodeEscape Char

sorts Nonterminal NonterminalLabel
lexical syntax
   [A-Z] [A-Za-z0-9\_]*           -> Nonterminal
   [a-z] [A-Za-z0-9\_]*           -> NonterminalLabel 

lexical restrictions
  Nonterminal -/- [A-Za-z0-9\_]
  NonterminalLabel -/- [A-Za-z0-9\_]

sorts Sym

context-free priorities
  Nonterminal "[" {Sym ","}+ "]"     -> Sym {cons("Parametrized")}
  non-assoc %% to prevent ambiguity with character classes
  Sym -> Sym+

context-free syntax
  nonterminal:Nonterminal            -> Sym {cons("Nonterminal")}
  symbol:Sym label:NonterminalLabel  -> Sym {cons("Labeled")}
  symbol:Sym "?"                     -> Sym {cons("Optional")}    
  symbol:Sym "??"                    -> Sym {cons("NonEagerOptional")}               
  symbol:Sym "+"                     -> Sym {cons("Iter")}                   
  symbol:Sym "*"                     -> Sym {cons("IterStar")} 
  symbol:Sym "+?"                    -> Sym {cons("NonEagerIter")}                   
  symbol:Sym "*?"                    -> Sym {cons("NonEagerIterStar")}
  "{" symbol:Sym sep:StringConstant "}" "+"  -> Sym {cons("IterSep")}                
  "{" symbol:Sym sep:StringConstant "}" "*"  -> Sym {cons("IterStarSep")} 
  "{" symbol:Sym sep:StringConstant "}" "+?" -> Sym {cons("NonEagerIterSep")}                
  "{" symbol:Sym sep:StringConstant "}" "*?" -> Sym {cons("NonEagerIterStarSep")} 


context-free syntax
    "^"                                    -> Sym {cons("StartOfLine")}
    "$"                                    -> Sym {cons("EndOfLine")}
    "@" column:IntegerLiteral              -> Sym {cons("Column")}
    charClass:Class                        -> Sym {cons("CharacterClass")}         
    string:StringConstant                  -> Sym {cons("Literal")}                
    cistring:CaseInsensitiveStringConstant -> Sym {cons("CaseInsensitiveLiteral")}

context-free restrictions
  Sym -/- [\?]

sorts Class Range

context-free syntax
  character:Char                      -> Range     {cons("Character")}                
  start:Char "-" end:Char        -> Range     {cons("FromTo")}                    
  "[" ranges:Range* "]"                -> Class     {cons("SimpleCharclass")}       
  "(" charclass:Class ")"              -> Class     {cons("Bracket"),bracket}

lexical syntax
  EscapeSequence   -> Char {category("Constant")}
  UnicodeEscape    -> Char {category("Constant")}
 ~[\"\'\\\-\[\]\ ] -> Char {category("Constant")}  
 "\\" [\-\[\]\ ]   -> Char {category("Constant")}
 

context-free priorities
  "!" charClass:Class     -> Class {cons("Complement")} >
  lhs:Class "-" rhs:Class -> Class {cons("Difference"), left} >
  lhs:Class "&" rhs:Class -> Class {cons("Intersection"), left} >
  lhs:Class "+" rhs:Class -> Class {cons("Union"), left}
