module rascal/syntax/Statements

imports rascal/syntax/Generators
        rascal/syntax/Declarations

exports
sorts Statement Bound

hiddens
context-free start-symbols Statement

exports
context-free syntax
                                                                               -> Bound     {cons("Empty")}   
  ";" expression:Expression                                                    -> Bound     {cons("Default")} 
  "solve" "(" variables:{QualifiedName ","}+ bound:Bound ")" body:Statement    -> Statement {cons("Solve")}   

context-free syntax
  label:Label "for" "(" generators:{Expression ","}+ ")" body:Statement                                         -> Statement {cons("For")}          
  label:Label "while" "(" conditions:{Expression ","}+ ")" body:Statement                                       -> Statement {cons("While")}      
  label:Label "do" body:Statement "while" "(" condition:Expression ")" ";"                                      -> Statement {cons("DoWhile")}    
  label:Label "if" "(" conditions:{Expression ","}+ ")" thenStatement:Statement "else" elseStatement:Statement  -> Statement {cons("IfThenElse")} 
  label:Label "if" "(" conditions:{Expression ","}+ ")" thenStatement:Statement noElseMayFollow:NoElseMayFollow -> Statement {cons("IfThen")}     
  label:Label "switch" "(" expression:Expression ")" "{" cases:Case+ "}"                                        -> Statement {cons("Switch")}     
  label:Label visit:Visit                                                                                       -> Statement {cons("Visit")}           

sorts NoElseMayFollow

context-free syntax
   -> NoElseMayFollow  {cons("Default")}

context-free restrictions
  NoElseMayFollow -/- [e].[l].[s].[e]

sorts Assignable

context-free syntax
  qualifiedName:QualifiedName                          -> Assignable {cons("Variable")}

context-free priorities
{
  receiver:Assignable "[" subscript:Expression "]"     -> Assignable {cons("Subscript")}   
  receiver:Assignable "." field:Name                   -> Assignable {cons("FieldAccess")} 
  receiver:Assignable "?" defaultExpression:Expression -> Assignable {cons("IfDefinedOrDefault")}    
}
<0> >
{non-assoc:    
  receiver:Assignable "@" annotation:Name              -> Assignable {non-assoc, cons("Annotation")}
  "<" elements:{Assignable ","}+ ">"                   -> Assignable {cons("Tuple")}       
  name:Name "(" arguments:{Assignable ","}+ ")"        -> Assignable {non-assoc, cons("Constructor")} 
}

sorts Assignment

context-free syntax
  "="  -> Assignment {cons("Default")}       
  "+=" -> Assignment {cons("Addition")}      
  "-=" -> Assignment {cons("Subtraction")}  
  "*=" -> Assignment {cons("Product")}       
  "/=" -> Assignment {cons("Division")}      
  "&=" -> Assignment {cons("Intersection")} 
  "?=" -> Assignment {cons("IfDefined")}

context-free restrictions
  "*" -/- [\=]
  "/" -/- [\=]
  "+" -/- [\=]
  "&" -/- [\=]
  "-" -/- [\=]
  "*" -/- [\=]
  "=" -/- [\=]
  "?" -/- [\=]

sorts Label

context-free syntax
  ";"                       -> Statement {cons("EmptyStatement")}
                            -> Label     {cons("Empty")}      
  name:Name ":"             -> Label     {cons("Default")}    
  expression:Expression ";" -> Statement {cons("Expression")} 


context-free priorities
  %% otherwise { x; }; is either block followed by no-op stat
  %% or exp followed by ;
  expression:Expression ";" -> Statement {cons("Expression")} 
  >  
  {
 "{" statements:Statement+ "}" -> Expression {cons("NonEmptyBlock")}
  label:Label visit:Visit -> Expression {cons("Visit")}
  }


context-free syntax
  assignable:Assignable operator:Assignment statement:Statement -> Statement {cons("Assignment")} 

context-free syntax
  "assert" expression:Expression ";"                    -> Statement {cons("Assert")}
  "assert" expression:Expression ":" message:Expression ";" -> Statement {cons("AssertWithMessage")}



context-free syntax
  "return" statement:Statement -> Statement {cons("Return")}
  "throw" statement:Statement  -> Statement {cons("Throw")}

context-free priorities 
  {non-assoc:
  assignable:Assignable operator:Assignment statement:Statement -> Statement {cons("Assignment")} 
  "return" statement:Statement -> Statement {non-assoc, cons("Return")}
  "throw" statement:Statement  -> Statement {non-assoc, cons("Throw")}
  "insert" dataTarget:DataTarget statement:Statement -> Statement {non-assoc, cons("Insert")}
  "append" dataTarget:DataTarget statement:Statement   -> Statement {non-assoc, cons("Append")}
  }
  >
  {
  functionDeclaration:FunctionDeclaration   -> Statement {cons("FunctionDeclaration")} 
  declaration:LocalVariableDeclaration ";" -> Statement                {cons("VariableDeclaration")} 
  }


sorts DataTarget
context-free syntax
                                                 -> DataTarget {cons("Empty")}
  label:Name ":"                                 -> DataTarget {cons("Labeled")}
  "insert" dataTarget:DataTarget statement:Statement -> Statement {cons("Insert")}
  "append" dataTarget:DataTarget statement:Statement   -> Statement {cons("Append")}


sorts Target
context-free syntax
                               -> Target {cons("Empty")}
  name:Name                    -> Target {cons("Labeled")}
  "break" target:Target ";"    -> Statement {cons("Break")}
  "fail" target:Target  ";"    -> Statement {cons("Fail")}
  "continue" target:Target ";" -> Statement {cons("Continue")}


sorts Catch

context-free syntax
  "catch" ":" body:Statement                                           -> Catch     {cons("Default")}        
  "catch" pattern:Pattern ":" body:Statement                           -> Catch     {cons("Binding")}         
  "try" body:Statement handlers:Catch+                                 -> Statement {non-assoc, cons("Try")} 
  "try" body:Statement handlers:Catch+ "finally" finallyBody:Statement -> Statement {cons("TryFinally")}     

context-free syntax
  label:Label "{" statements:Statement+ "}" -> Statement {cons("NonEmptyBlock")}               
  functionDeclaration:FunctionDeclaration   -> Statement {cons("FunctionDeclaration")} 

sorts LocalVariableDeclaration Declarator

context-free syntax
  declaration:LocalVariableDeclaration ";" -> Statement                {cons("VariableDeclaration")} 
  type:Type variables:{Variable ","}+      -> Declarator               {cons("Default")}             
  declarator:Declarator                    -> LocalVariableDeclaration {cons("Default")}             
  "dynamic" declarator:Declarator          -> LocalVariableDeclaration {cons("Dynamic")}   

context-free priorities
  %% this complicated, injection skipping & post-parse, priority fixes a nasty ambiguity (consider "D+ d;")
  type:Type variables:{Variable ","}+      -> Declarator               {cons("Default")} 
  >
  {
    type:Type "?"                     -> Type {cons("Optional")}               
    type:Type "+"                     -> Type {cons("Iter")}                   
    type:Type "*"                     -> Type {cons("IterStar")}   
  }
  

context-free syntax
  "global" type:Type names:{QualifiedName ","}+ ";" -> Statement {cons("GlobalDirective")} 
