module rascal/syntax/Expressions

imports 
        rascal/syntax/Statements
        rascal/syntax/Constructors
exports
sorts Expression

hiddens
context-free start-symbols Expression

exports

sorts
 Formals Formal Parameters
context-free syntax
  type:Type name:Name                                                  -> Formal {cons("TypeName")}
  formals:{Formal ","}*                                                -> Formals {cons("Default")}
  "(" formals:Formals ")"                                              -> Parameters {cons("Default")}

  "(" formals:Formals "..." ")"                                        -> Parameters {cons("VarArgs")}

context-free syntax
  type:Type parameters:Parameters "{" statements:Statement+ "}"        -> Expression {cons("Closure")} 
  parameters:Parameters "{" statements:Statement* "}"                  -> Expression {cons("VoidClosure")} 
  "{" statements:Statement+ "}"                                        -> Expression {cons("NonEmptyBlock")}
  label:Label visit:Visit                                              -> Expression {cons("Visit")}


context-free syntax
  "(" expression:Expression ")"                                        -> Expression {cons("Bracket"),bracket} 

context-free syntax
  "[" first:Expression ".."  last:Expression "]"                       -> Expression {cons("Range")}     
  "[" first:Expression "," second:Expression ".." last:Expression "]"  -> Expression {cons("StepRange")} 

context-free syntax
  "#" type:Type -> Expression {cons("ReifyType")}

sorts ProtocolTail
context-free syntax
    mid:MidProtocolChars expression:Expression tail:ProtocolTail -> ProtocolTail {cons("Mid")}
    post:PostProtocolChars                        -> ProtocolTail {cons("Post")}
    pre:PreProtocolChars expression:Expression tail:ProtocolTail -> ProtocolPart {cons("Interpolated")}
  
sorts PathTail
context-free syntax
    mid:MidPathChars expression:Expression tail:PathTail         -> PathTail {cons("Mid")}
    post:PostPathChars                            -> PathTail {cons("Post")}
    pre:PrePathChars expression:Expression tail:PathTail         -> PathPart {cons("Interpolated")}


sorts StringTail StringMiddle StringTemplate
context-free syntax
    mid:MidStringChars expression:Expression tail:StringTail -> StringTail {cons("MidInterpolated")}
    mid:MidStringChars template:StringTemplate tail:StringTail -> StringTail {cons("MidTemplate")}
    post:PostStringChars -> StringTail {cons("Post")}
    pre:PreStringChars expression:Expression tail:StringTail -> StringLiteral {cons("Interpolated")}
    pre:PreStringChars template:StringTemplate tail:StringTail -> StringLiteral {cons("Template")}


    mid:MidStringChars -> StringMiddle {cons("Mid")}
    mid:MidStringChars expression:Expression tail:StringMiddle -> StringMiddle {cons("Interpolated")}
    mid:MidStringChars template:StringTemplate tail:StringMiddle -> StringMiddle {cons("Template")}

    "for" "(" generators:{Expression ","}+ ")" "{" preStats:Statement* body:StringMiddle postStats:Statement* "}" -> StringTemplate {cons("For")}
    "if" "(" conditions:{Expression ","}+ ")" "{" preStats:Statement* body:StringMiddle postStats:Statement* "}" -> StringTemplate {cons("IfThen")}
    "if" "(" conditions:{Expression ","}+ ")" "{" preStatsThen:Statement* thenString:StringMiddle postStatsThen:Statement* "}" "else" "{" preStatsElse:Statement* elseString:StringMiddle postStatsElse:Statement*  "}" -> StringTemplate {cons("IfThenElse")}
    "while" "(" condition:Expression ")" "{" preStats:Statement* body:StringMiddle postStats:Statement* "}" -> StringTemplate {cons("While")}
    "do" "{" preStats:Statement* body:StringMiddle  postStats:Statement* "}" "while" "(" condition:Expression ")" -> StringTemplate {cons("DoWhile")}    

sorts
    Field
    
context-free syntax
  	fieldName:Name                                                  -> Field {cons("Name")}
  	fieldIndex:IntegerLiteral                                       -> Field {cons("Index")}            

context-free priorities
  {
  basicType:BasicType "(" arguments:{Expression ","}* ")"                 -> Expression {cons("ReifiedType")}
  expression:Expression "(" arguments:{Expression ","}* ")"          -> Expression {cons("CallOrTree")}
  expression:Expression "[" key:Name "=" replacement:Expression "]"  -> Expression {cons("FieldUpdate")}
  expression:Expression "." field:Name                               -> Expression {cons("FieldAccess")}
  expression:Expression "<" fields:{Field ","}+ ">"                  -> Expression {cons("FieldProject")}
  expression:Expression "[" subscripts: {Expression ","}+"]"         -> Expression {cons("Subscript")}
  }
  <0>
  >
  {
  argument:Expression "?"               -> Expression {cons("IsDefined")}
  }
  >
  {
  "!" argument:Expression               -> Expression {cons("Negation")}
  "-" argument:Expression               -> Expression {cons("Negative")}
  }
  >
  {
    argument:Expression "*"             -> Expression {cons("TransitiveReflexiveClosure")}
    argument:Expression "+"             -> Expression {cons("TransitiveClosure")}                             
  }
  >
  {
  expression:Expression "@" name:Name   -> Expression {cons("GetAnnotation")} 
  expression:Expression "[" "@" name:Name "=" value: Expression "]"
                                        -> Expression {cons("SetAnnotation")}
  }
  >
  lhs:Expression "o" rhs:Expression     -> Expression {cons("Composition"), left}
  >
  {left:
  lhs:Expression "*" rhs:Expression     -> Expression {cons("Product"), left}
  lhs:Expression "join" rhs:Expression-> Expression {cons("Join"), left}
  }
  >
  {left:
  lhs:Expression "/" rhs:Expression     -> Expression {cons("Division"), left} 
  lhs:Expression "%" rhs:Expression     -> Expression {cons("Modulo"), left} 
  }
  >
  lhs:Expression "&" rhs:Expression   -> Expression {cons("Intersection"), left} 
  >
  {left:
    lhs:Expression "+" rhs:Expression   -> Expression {cons("Addition"), left}                                   
    lhs:Expression "-" rhs:Expression   -> Expression {cons("Subtraction"), left}
  } 
  
  >
  {non-assoc:
  lhs:Expression "notin" rhs:Expression -> Expression {non-assoc,cons("NotIn")}
  lhs:Expression "in" rhs:Expression    -> Expression {non-assoc,cons("In")}
  }
  >
  {non-assoc:
    lhs:Expression "<" rhs:Expression   -> Expression {non-assoc,cons("LessThan")}
    lhs:Expression "<=" rhs:Expression  -> Expression {non-assoc,cons("LessThanOrEq")}
    lhs:Expression ">" rhs:Expression   -> Expression {non-assoc,cons("GreaterThan")}
    lhs:Expression ">=" rhs:Expression  -> Expression {non-assoc,cons("GreaterThanOrEq")}
  }
  >
  {left:
    lhs:Expression "==" rhs:Expression  -> Expression {left,cons("Equals")}
    lhs:Expression "!=" rhs:Expression  -> Expression {left,cons("NonEquals")}
    condition:Expression "?" thenExp:Expression ":" elseExp:Expression -> Expression {right,cons("IfThenElse")}
  }
  >
  lhs:Expression "?" rhs:Expression     -> Expression {non-assoc,cons("IfDefinedOtherwise")}
  >
  {non-assoc:
  lhs:Expression "==>" rhs:Expression   -> Expression {right, cons("Implication")}
  lhs:Expression "<==>" rhs:Expression  -> Expression {right, cons("Equivalence")}
  }
  >
  lhs:Expression "&&" rhs:Expression    -> Expression {left, cons("And")} 
  >
  lhs:Expression "||" rhs:Expression    -> Expression {left, cons("Or")}

context-free priorities
  %% removes non-sensical a + - b (equal to a - b), which fixes ambiguity with transitive closure
  { Expression "+" Expression -> Expression
    Expression "*" Expression -> Expression 
  }.<2>> "-" Expression -> Expression

context-free restrictions
  "&" -/- [\&]
  "<" -/- [\=]
  ">" -/- [\=]
  "!" -/- [\~]
  "!" -/- [\=]
  "notin" -/- [a-zA-Z\-\_0-9]
  "in" -/- [a-zA-Z\-\_0-9]
  "join" -/- [a-zA-Z\-\_0-9]
  "o" -/- [a-zA-Z\-\_0-9]
  "==" -/- [\>]
  "<=" -/- [\=].[\>]



