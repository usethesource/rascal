@synopsis{Provides access to the JDK javac compiler, to compile (generated) Java code.}
module lang::rascalcore::java::Compiler

extend Message;

import IO;
import Location;
import String;
import util::FileSystem;
import util::Reflective;

@synopsis{Compile all the .java files in source folders in PathConfig}
list[Message] compileJava(PathConfig pcfg) 
    = compileJavaSourceFolders(pcfg.srcs, pcfg.bin, libs=pcfg.libs);

@synopsis{Compile the generated sources from a PathConfig}
@description{
It is assumed that the pcfg.generatedSources folder is already filled with generated Java 2code.
}
list[Message] compileGeneratedSources(PathConfig pcfg)
    = compileJavaSourceFolders([pcfg.generatedSources], pcfg.bin, libs=pcfg.libs);

@synopsis{Compile a single Java source file}
@pitfalls{
* `file` has to be reachable from `srcs`
}
list[Message] compileJavaSourceFile(loc file, loc bin, list[loc] srcs, list[loc] libs=[]) 
    = compileJava({<file, qualifiedName(file, srcs), readFile(file)>}, bin, libs=libs);

@synopsis{Compile all java source files from a list of source folders.}
@description{
Qualified names are obtained by relativizing against the source folders.
}
list[Message] compileJavaSourceFolders(list[loc] srcFolders, loc bin, list[loc] libs=[])
    = compileJava({<f, qualifiedName(f, srcFolders), readFile(f)> | src <- srcFolders, f <- find(src, "java")}, bin, libs=libs);

@synopsis{Call the Java compiler on a list of files, reading in their contents first and computing their qualified names}
list[Message] compileJava(list[loc] sources, loc bin, list[loc] srcs=[], list[loc] libs=[])
    = compileJava({<s, qualifiedName(s, srcs), readFile(s)> | s <- sources}, bin, libs=libs);

@synopsis{Main workhorse for compiling Java source code}
@benefits{
* Use in memory cache to optimize compiling a lot of files at once
* Can work with any kind of source loc or target loc
}
@pitfalls{
* The sources relation must match the right file name to the right source code, for accurate error messages.
* The sources relation must give the right qualified name to the right source code, otherwise the compilation fails.
* While `compileJava` is running all source code and all generated bytecode will be in memory; this can be significant.
if you need to use less memory then call `compileJava` several times with a smaller relation.
}
@javaClass{org.rascalmpl.compiler.lang.rascalcore.java.JavaCompilerForRascal}
java list[Message] compileJava(rel[loc fileName, str qualifiedName, str sourceCode] sources, loc bin, list[loc] libs=[]);

@synopsis{finds the packageName.className fully qualified name for a source path by relativizing with the srcs folder and replaces / by .}
private str qualifiedName(loc path, list[loc] srcs)
    = replaceAll(".", "/", relativize(srcs, path).path[1..]) 
    when path.extension == "java";