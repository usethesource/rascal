@synopsis{Provides access to the JDK javac compiler, to compile (generated) Java code.}
module lang::rascalcore::java::Compiler

extend Message;
import IO;
import util::FileSystem;

@synopsis{Compile a single source file}
list[Message] compileJavaSourceFile(loc file, loc bin, list[loc] classpath=[]) 
    = compileJava((file : readFile(file)), bin, classpath=classpath);

@synopsis{Compile all java source files from a list of source folders}
list[Message] compileJavaSourceFolders(list[loc] srcFolders, loc bin, list[loc] classpath=[])
    = compileJava((f : readFile(f) | src <- srcFolders, f <- find(src, "java")), bin, classpath=classpath);

@synopsis{Call the Java compiler on a list of files, reading in their contents first.}
list[Message] compileJava(list[loc] sources, loc bin, list[loc] classpath=[])
    = compileJava((s : readFile(s) | s <- sources), bin, classpath=classpath);

@synopsis{Main workhorse for compiling Java source code}
@benefits{
* Use in memory cache to optimize compiling a lot of files at once
* Can work with any kind of source loc or target loc
}
@pitfalls{
* sources map must match the right file name to the right source code
* while `compileJava` is running all source code and all generated bytecode will be in memory; this can be significant.
if you need to use less memory then call `compileJava` several times with a smaller map.
}
@javaClass{org.rascalmpl.compiler.lang.rascalcore.java.JavaCompilerForRascal}
java list[Message] compileJava(map[loc fileName, str sourceCode] sources, loc bin, list[loc] classpath=[]);