/*******************************************************************************
 * Copyright (c) 2009-2019 CWI
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:

 *   * Jurgen J. Vinju - Jurgen.Vinju@cwi.nl - CWI
 *   * Anya Helene Bagge - anya@ii.uib.no (Univ. Bergen)
 *   * Arnold Lankamp - Arnold.Lankamp@cwi.nl
*******************************************************************************/
package org.rascalmpl.parser;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.Collections;

import org.rascalmpl.debug.IRascalMonitor;
import org.rascalmpl.exceptions.ImplementationError;
import org.rascalmpl.exceptions.Throw;
import org.rascalmpl.interpreter.Configuration;
import org.rascalmpl.interpreter.Evaluator;
import org.rascalmpl.interpreter.utils.JavaBridge;
import org.rascalmpl.parser.gtd.IGTD;
import org.rascalmpl.runtime.ModuleStore;
import org.rascalmpl.runtime.RascalExecutionContext;
import org.rascalmpl.uri.URIResolverRegistry;
import org.rascalmpl.values.IRascalValueFactory;
import org.rascalmpl.values.parsetrees.ITree;
import rascal.lang.rascal.grammar.$ParserGenerator;
import rascal.lang.rascal.grammar.$ConcreteSyntax;
import rascal.lang.rascal.grammar.definition.$Modules;
import rascal.lang.rascal.grammar.definition.$Priorities;
import rascal.lang.rascal.grammar.definition.$Regular;
import rascal.lang.rascal.grammar.definition.$Keywords;
import rascal.lang.rascal.grammar.definition.$Literals;
import rascal.lang.rascal.grammar.definition.$Symbols;
import rascal.lang.rascal.grammar.definition.$Parameters;

import io.usethesource.vallang.IConstructor;
import io.usethesource.vallang.IInteger;
import io.usethesource.vallang.IMap;
import io.usethesource.vallang.ISet;
import io.usethesource.vallang.ISourceLocation;
import io.usethesource.vallang.IString;
import io.usethesource.vallang.IValueFactory;

public class ParserGenerator {
	private final $ParserGenerator pgen;
	private final $ConcreteSyntax concreteSyntax;
	private final $Modules modules;
	private final $Priorities priorities;
	private final $Regular regular;
	private final $Keywords keywords;
	private final $Literals literals;
	private final $Parameters parameters;
	private final $Symbols symbols;
	
	private final JavaBridge bridge;
	private final IValueFactory vf;
	private static final String packageName = "org.rascalmpl.java.parser.object";
	private static final boolean debug = false;

	public ParserGenerator(IRascalMonitor monitor, PrintWriter out, IValueFactory factory, Configuration config) {
		var rex = new RascalExecutionContext(null, out, out, null, null, $ParserGenerator.class);
		ModuleStore ms = rex.getModuleStore();
		pgen = new $ParserGenerator(rex);
		concreteSyntax = ms.getModule($ConcreteSyntax.class);
		modules =  ms.getModule($Modules.class);
		priorities = ms.getModule($Priorities.class);
		symbols =  ms.getModule($Symbols.class);
		regular =  ms.getModule($Regular.class);
		literals =  ms.getModule($Literals.class);
		parameters = ms.getModule($Parameters.class);
		keywords =  ms.getModule($Keywords.class);
		this.bridge = new JavaBridge(Collections.singletonList(Evaluator.class.getClassLoader()), factory, config);
		this.vf = factory;
	}
	
	private void debugOutput(Object thing, String file) {
		if (debug) {
			String classString = thing.toString();
			FileOutputStream s = null;
			try {
			    System.err.println("Writing parser to " + file);
				s = new FileOutputStream(file);
				s.write(classString.getBytes());
				s.flush();
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			} catch (IOException e) {
				e.printStackTrace();
			} finally {
				if (s != null) {
					try {
						s.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
				}
			}
		}
	}
	
	public IConstructor getGrammarFromModules(IRascalMonitor monitor, String main, IMap mods) {
		return modules.modules2grammar(vf.string(main), mods);
	}
	
	public IConstructor getExpandedGrammar(IRascalMonitor monitor, String main, IMap definition) {
		IConstructor g = getGrammarFromModules(monitor, main, definition);
		g = keywords.expandKeywords(g);
		g = (IConstructor) regular.makeRegularStubs(g); // why is the return type IValue here?
		g = regular.expandRegularSymbols(g);
		g = parameters.expandParameterizedSymbols(g);
		g = literals.literals(g);

		return g;
	}

	public ISet getNestingRestrictions(IRascalMonitor monitor, IConstructor g) {
		return priorities.doNotNest(g);
	}

	/** 
	 * Produces the name generated by the parser generator for a parse method for the given symbol
	 */
	public String getParserMethodName(IConstructor symbol) {
		return pgen.getParserMethodName(symbol).getValue();
	}
	
	/**
	 * Converts the parse tree of a symbol to a UPTR symbol
	 */
	public IConstructor symbolTreeToSymbol(IConstructor symbol) {
		return symbols.sym2symbol(symbol);
	}
	
  /**
   * Generate a parser from a Rascal syntax definition (a set of production rules).
   * 
   * @param monitor a progress monitor; this method will contribute 100 work units
   * @param loc     a location for error reporting
   * @param name    the name of the parser for use in code generation and for later reference
   * @param definition a map of syntax definitions (which are imports in the Rascal grammar)
   * @return A parser class, ready for instantiation
   */
	public Class<IGTD<IConstructor, ITree, ISourceLocation>> getNewParser(IRascalMonitor monitor, ISourceLocation loc, String name, IMap definition) {
		try {
			IConstructor grammar = IRascalValueFactory.getInstance().grammar(definition);
			debugOutput(grammar, System.getProperty("java.io.tmpdir") + "/grammar.trm");
			return getNewParser(monitor, loc, name, grammar);
		} 
		catch (ClassCastException e) {
			throw new ImplementationError("parser generator:" + e.getMessage(), e);
		} 
		catch (Throw e) {
			throw new ImplementationError("parser generator: " + e.getMessage() + e.getTrace());
		} 
	}

  /**
   * Generate a parser from a Rascal grammar.
   * 
   * @param monitor a progress monitor; this method will contribute 100 work units
   * @param loc     a location for error reporting
   * @param name    the name of the parser for use in code generation and for later reference
   * @param grammar a grammar
   * @return A parser class, ready for instantiation
   */
	public Class<IGTD<IConstructor, ITree, ISourceLocation>> getNewParser(IRascalMonitor monitor, ISourceLocation loc, String name, IConstructor grammar) {
		try {
			String normName = name.replaceAll("::", "_").replaceAll("\\\\", "_");
			
			IString classString = pgen.newGenerate(vf.string(packageName), vf.string(normName), grammar);
			debugOutput(classString, System.getProperty("java.io.tmpdir") + "/parser.java");
			
			return bridge.compileJava(loc, packageName + "." + normName, classString.getValue());
		} catch (ClassCastException e) {
			throw new ImplementationError("parser generator:" + e.getMessage(), e);
		} catch (Throw e) {
			throw new ImplementationError("parser generator: " + e.getMessage() + e.getTrace());
		}
	}

	/**
   * Generate a parser from a Rascal grammar and write it to disk
   * 
   * @param monitor a progress monitor; this method will contribute 100 work units
   * @param loc     a location for error reporting
   * @param name    the name of the parser for use in code generation and for later reference
   * @param grammar a grammar
   * @return A parser class, ready for instantiation
	 * @throws IOException
   */
  public void writeNewParser(IRascalMonitor monitor, ISourceLocation loc, String name, IMap definition, ISourceLocation target) throws IOException {
	try (OutputStream out = URIResolverRegistry.getInstance().getOutputStream(target, false)) {
		String normName = name.replaceAll("::", "_").replaceAll("\\\\", "_");
		IConstructor grammar = IRascalValueFactory.getInstance().grammar(definition);

		IString classString = pgen.newGenerate(vf.string(packageName), vf.string(normName), grammar);
		
		debugOutput(classString, System.getProperty("java.io.tmpdir") + "/parser.java");
		
		bridge.compileJava(loc, packageName + "." + normName, classString.getValue(), out);
	} catch (ClassCastException e) {
		throw new ImplementationError("parser generator:" + e.getMessage(), e);
	} catch (Throw e) {
		throw new ImplementationError("parser generator: " + e.getMessage() + e.getTrace());
	}
}

	public IString createHole(IConstructor part, IInteger size) {
		return concreteSyntax.createHole(part, size);
	}
}
