conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/List/Concatenation/Concatenation.concept|
QChoice: When you compute the concatenation of two lists, the number of elements in the result is always:
b: Greater than the sum of the number of elements in both lists.
g: Greater than or equal to the sum of the number of elements in both lists.
b: Smaller than the sum of the number of elements in both lists.
g: Equal to the sum of the number of elements in both lists.

QType: <A:list[arb[int,str]]> + <B:same[A]>

QValue: <A:list[arb[int,str]]> + <B:same[A]>

QValue:
make: A = list[arb[int,str]]
make: B = same[A]
expr: C = <A> + <B>
hint: <B>
test: <A> + <?> == <C>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/List/notin/notin.concept|
QType: <A:arb[int,str,bool]> notin <B:list[same[A]]>


QValue:
prep: import Set;
make: ELM = int[0,100]
make: A = set[same[ELM]]
expr: A1 = toList( {<ELM>} + <A>)
expr: C =  <ELM> notin <A1>
hint: <C>
test: <ELM> notin <A1> == <?>

QValue:
prep: import Set;
make: ELM = int[0,10]
make: A = list[same[ELM]]
expr: C =  <ELM> notin <A>
hint: <C>
test: <ELM> notin <A> == <?>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/ListRelation/Composition/Composition.concept|
QType:
prep: import List;
make: C = list[int,3,3]
make: A = list[int,3,3]
make: B = list[int,3,3]
expr: S1 = zip(<A>,<C>)
expr: S2 = zip(<C>, <B>)
test: <S1> o <S2>

QValue:
prep: import List;
make: C = list[int,3,3]
make: A = list[int,3,3]
make: B = list[int,3,3]
expr: S1 = zip(<A>,<C>)
expr: S2 = zip(<C>, <B>)
expr: H = <S1> o <S2>
hint: <H>
test: <S1> o <S2>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/Relation/Composition/Composition.concept|
QType:
prep: import List;
make: C = list[int,3,3]
make: A = list[int,3,3]
make: B = list[int,3,3]
expr: S1 = toSet(zip(<A>,<C>))
expr: S2 = toSet(zip(<C>, <B>))
test: <S1> o <S2>

QValue:
prep: import List;
make: C = list[int,3,3]
make: A = list[int,3,3]
make: B = list[int,3,3]
expr: S1 = toSet(zip(<A>,<C>))
expr: S2 = toSet(zip(<C>, <B>))
expr: H = <S1> o <S2>
hint: <H>
test: <S1> o <S2>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/List/SuperList/SuperList.concept|
QType: <A:list[arb]> >= <B:same[A]>


QValue:
prep: import Set;
make: DIFF = set[int[0,100]]
make: B = same[DIFF]
expr: A = toList(<B> + <DIFF>)
expr: B1 = toList(<B>)
expr: C =  <A> >= <B1>
hint: <C>
test: <A> >= <B1> == <?>

QValue:
make: A = list[arb[int,str,bool]]
expr: C = <A> >= <A>
hint: <C>
test: <A> >= <A>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/Number/Equal/Equal.concept|
QType:  <A:int> == <B:int>
QType:  <A:real> == <B:real>
QType:  <A:num> == <B:num>
QType:  <A:num> == <B:num>
QValue: <A:num> == <B:num>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/Number/Subtraction/Subtraction.concept|
QType:  <A:int> - <B:int>
QType:  <A:int> - <B:real>
QType:  <A:real> - <B:int>
QValue: <A:num> - <B:num>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/Map/Map.concept|
QChoice: A map maps keys to values. In a map:
g: All keys have to be unique.
g: All keys have the same type.
g: All keys should have the same type and all values should have the same type. The type of keys and values may be different.
b: All keys should have the same type and all values should have the same type. The type of keys and values should be the same.
b: All values have to be unique.
b: All keys and values have to be unique.
b: All keys are sorted.

QValue:
desc: Complete this function that returns the set of keys with the smallest associated value.
list:
import Map;
import Set;
inventory = ("orange" : 20, "apple" : 15, "banana" : 25, "lemon" : 15);
public set[str] lowest(map[str,int] inv){
    m = <?>; // Determine the minimal value in the map
    return { s  | s <- inv, inv[s] == m };
}
test: lowest(inventory) == {"apple", "lemon"};
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Patterns/Abstract/List/List.concept|
QValue:
desc: Complete this function that tests that a list of words consists of two identical sublists:
list:
import List;
public bool isReplicated(list[str] words){
  return [*str L, <?>] := words;
}
test: isReplicated(["a", "b", "a", "b"]) == true;
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/Number/Remainder/Remainder.concept|
QType:  <A:int> % <B:int>
QValue: <A:int> % <B:int>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Libraries/Prelude/List/List.concept|
QValue:
desc: Fill in the missing function name.
prep: import List;
make: L = list[arb[int,str],4,6]
make: I = int[0,3]
expr: E = <L>[<I>]
expr: H = indexOf(<L>, <E>)
hint: indexOf
test: <?>(<L>, <E>) == <H>

QValue:
desc: Fill in the missing function name.
prep: import List;
make: E = arb[int,str]
make: L = list[same[E],4,6]
make: I = int[0,3]
expr: H = insertAt(<L>, <I>, <E>)
hint: insertAt
test: <?>(<L>, <I>, <E>) == <H>

QValue:
desc: Fill in the missing function name.
prep: import List;
make: L = list[int,0,5]
expr: H = intercalate(";", <L>) 
hint: intercalate
test: <?>(";", <L>) == <H>


QValue:
desc: Fill in the missing function name.
prep: import List;
make: L = list[arb[int,str],0,5]
expr: H = index(<L>)
hint: index
test: <?>(<L>) == <H>

QValue:
desc: Fill in the missing function name.
prep: import List;
make: L = list[arb[int,str],1,6]
expr: H = head(<L>)
hint: head
test: <?>(<L>) == <H>

QValue:
desc: Fill in the missing function name.
prep: import List;
make: L = list[arb[int,str], 1, 6]
expr: H =  last(<L>)
hint: last
test: <?>(<L>) == <H>

QValue:
desc: Fill in the missing function name.
prep: import List;
make: L = list[arb[int,str]]
expr: H = toSet(<L>)
hint: toSet
test: <?>(<L>) == <H>

QValue:
desc: Fill in the missing function name.
prep: import List;
make: L = list[arb[bool,int,str],4,6]
make: N = int[0,3]
expr: H = take(<N>, <L>)
hint: take
test: <?>(<N>, <L>) == <H>

QValue:
desc: Fill in the missing function name.
prep: import List;
make: L = list[arb[bool,int,str],4,6]
make: N = int[0,3]
expr: H = tail(<L>,<N>)
hint: tail
test: <?>(<L>,<N>) == <H>


QValue:
desc: Fill in the missing function name.
prep: import List;
make: L = list[arb[int,str],1,5]
expr: H = headTail(<L>)
hint: Use headTail.
test: <?>(<L>) == <H>

QValue:
desc: Fill in the missing function name.
prep: import List;
make: L = list[arb[bool,int,str],4,6]
make: I = int[0,3]
make: J = int[0,3]
expr: L1 = [<L>[<I>], <L>[<J>], *<L>, <L>[<J>], <L>[<I>]]
expr: H = dup(<L1>)
hint: dup
test: <?>(<L1>) == <H>

QValue:
desc: Fill in the missing function name.
prep: import List;
make: L = list[arb[bool,int,str],2,5]
expr: H = getOneFrom(<L>)
hint: getOneFrom
test: <?>(<L>) == <H>

QValue:
desc: Fill in the missing function name.
prep: import List;
make: L = list[arb[bool,int,str],3,4]
make: N = int[0,2]
expr: H = drop(<N>, <L>)
hint: drop
test: <?>(<N>, <L>) == <H>

QValue:
desc: Fill in the missing function name.
prep: import List;
make: L = list[arb[int,str],0,5]
expr: H =  reverse(<L>) 
hint: reverse
test: <?>(<L>) == <H>

QValue:
desc: Fill in the missing function name.
prep: import List;
make: L = list[arb[int,str],3,4]
make: I = int[0,2]
expr: E = <L>[<I>]
expr: L1 = reverse(<L>) + <L>
expr: H = lastIndexOf(<L1>, <E>)
hint: lastIndexOf
test: <?>(<L1>, <E>) == <H>

QValue:
desc: Fill in the missing function name.
prep: import List;
make: L = list[arb[int,str],0,5]
expr: H = index(<L>)
hint: index
test: <?>(<L>) == <H>

QValue:
desc: Fill in the missing function name.
prep: import List;
make: L = list[arb[int,str],1,5]
expr: H = pop(<L>)
hint: pop
test: <?>(<L>) == <H>


QValue:
prep: import List;
make: L = list[arb[int,str], 1, 6]
expr: H = max(<L>)
hint: max
test: <?>(<L>) == <H>

QValue:
desc: Fill in the missing function name.
prep: import List;
make: L = list[int[-20,20]]
expr: H = takeWhile(<L>, bool(int x){ return x > 0;})
hint: takeWhile
test: <?>(<L>, bool(int x){ return x > 0;}) == <H>

QValue:
desc: Fill in the missing function name.
prep: import List;
make: L = list[arb[int,str],3,4]
make: I = int[0,2]
expr: C = delete(<L>, <I>)
hint: delete
test: <?>(<L>, <I>) == <C>

QValue:
desc: Fill in the missing function name.
prep: import List;
make: L = list[int,2,7]
expr: H = sum(<L>)
hint: sum
test: <?>(<L>) == <H>

QValue:
desc: Fill in the missing function name.
prep: import List;
make: L = list[int, 4, 4]
make: M = list[int, 4, 4]
expr: Z = zip(<L>,<M>)
hint: zip
test: <?>(<L>, <M>) == <Z>


QValue:
desc: Fill in the missing function name.
prep: import List;
make: L = list[arb[int,str],1,5]
expr: H = sort(<L>)
hint: sort
test: <?>(<L>) == <H>


QValue:
prep: import List;
make: L = list[int, 1,5]
expr: H = mapper(<L>, int(int n){ return n + 1; })
hint: mapper
list:
int incr(int x) { return x + 1; }
test: <?>(<L>, incr) == <H>

QValue:
desc: Complete this function that tests that a list of words forms a palindrome. A palindrome is a word that is symmetrical 
and can be read
from left to right and from right to left.
list:
import List;
public bool isPalindrome(list[str] words){
  return words == <?>;
}
test: isPalindrome(["a", "b", "b", "a"]) == true;
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/Number/Conditional/Conditional.concept|
QType: (<A:int> > <B:int>) ? <C:int> : <D:int>

QType: (<A:int> > <B:int>) ? <C:real> : <D:real>

QType: (<A:int> > <B:int>) ? <C:int> : <D:real>

QValue: (<A:int> > <B:int>) ? <C:int> : <D:int>

QValue: (<A:int> > <B:int>) ? <C:int> : <D:real>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/Set/Equal/Equal.concept|
QType: <A:set[arb]> == <B:same[A]>

QValue:
make: A = set[arb[int[0,10],str]]
expr: C =  <A> == <A>
hint: <C>
test: (<A> == <A>) == <?>

QValue:
make: A = set[int[0,100]]
make: DIFF = int
expr: B = <A> + (<DIFF>)
expr: C =  <A> == <B>
hint: <C>
test: (<A> == <B>) == <?>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/Set/Comprehension/Comprehension.concept|
QType:
make: I = int[0,5]
make: J = int[7,12]
test: { N + 1 | int N <- [<I> .. <J>] }

QValue:
make: I = int[0,5]
make: J = int[7,12]
expr: H = { N + 1 | int N <- [<I> .. <J>] }
hint: <H>
test: { N + 1 | int N <- [<I> .. <J>] } == <?>

QValue:
make: S = set[int]
expr: H = { 2 * N | int N <- <S> } 
hint: <H>
test: { 2 * N | int N <- <S> } == <?>

QValue:
desc: Complete this comprehension:
make: S = set[int]
expr: H = { N - 1 | int N <- <S> } 
hint: { N - 1 | int N <- <S> } 
test: { <?> | int N <- <S> } == <H>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/Integer/Integer.concept|
QType: <A:int>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/Number/LessThanOrEqual/LessThanOrEqual.concept|
QType:  <A:int> <= <B:int>
QType:  <A:real> <= <B:real>
QType:  <A:num> <= <B:num>
QType:  <A:num> <= <B:num>
QValue: <A:num> <= <B:num>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/ListRelation/Subscription/Subscription.concept|
QValue:
desc: Using the above example with GDP values:
prep: lrel[str country, int year, int amount] GDP = [<"US", 2008, 14264600>, <"EU", 2008, 18394115>,<"Japan", 2008, 4923761>, <"US", 2007, 13811200>, <"EU", 2007, 13811200>, <"Japan", 2007, 4376705>];
expr: H = GDP["US"]
hint: <H>
test: GDP["US"] == <?>

QValue:
desc: Using the above example with GDP values:
prep: lrel[str country, int year, int amount] GDP = [<"US", 2008, 14264600>, <"EU", 2008, 18394115>,<"Japan", 2008, 4923761>, <"US", 2007, 13811200>, <"EU", 2007, 13811200>, <"Japan", 2007, 4376705>];
expr: H = GDP["US",2008]
hint: <H>
test: GDP["US",2008] == <?>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/ListRelation/FieldSelection/FieldSelection.concept|
QValue:
hint: A list consisting of the first element of each tuple.
list:
lrel[str animal, int nlegs] legs = [<"bird", 2>, <"dog", 4>, <"human", 2>, <"snake", 0>, <"spider", 8>, <"millepede", 1000>, <"crab", 8>, <"cat", 4>];
test: legs.animal == <?>

QValue:
hint: A list consisting of the second element of each tuple.
list:
lrel[str animal, int nlegs] legs = [<"bird", 2>, <"dog", 4>, <"human", 2>, <"snake", 0>, <"spider", 8>, <"millepede", 1000>, <"crab", 8>, <"cat", 4>];
test: legs.nlegs == <?>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/ListRelation/ReflexiveTransitiveClosure/ReflexiveTransitiveClosure.concept|
QType:
prep: S = [<1,2>, <2,3>];
make: A = list[tuple[int[0,5],int[0,5]],1,2]
expr: B = <A> + S
test: <B>*

QValue:
prep: S = [<1,2>, <2,3>, <3,4>];
make: A = list[tuple[int[0,5],int[0,5]],1,2]
expr: B = <A> + S
expr: H =  <B>*
hint: <H>
test: <B>*
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/ListRelation/Join/Join.concept|
QType:  <A:list[tuple[int,str]]> join <B:list[tuple[str,int]]>
QValue: <A:list[tuple[int,str],2,2]> join <B:list[tuple[str,int],2,2]>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Visit/Visit.concept|
QValue:
desc: Given a data type `ColoredTree`, complete the definition of the function `flipRedChildren` that exchanges the children of all red nodes.
list:
data ColoredTree = leaf(int N)      
                 | red(ColoredTree left, ColoredTree right) 
                 | black(ColoredTree left, ColoredTree right);

ColoredTree rb = red(black(leaf(1), red(leaf(2),leaf(3))), black(leaf(3), leaf(4)));

public ColoredTree flipRedChildren(ColoredTree t){
  return visit(t){
     case red(l,r) => <?>
  };
}
test: flipRedChildren(rb) == red( black(leaf(3), leaf(4)), black(leaf(1), red(leaf(3),leaf(2))));
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/ListRelation/CartesianProduct/CartesianProduct.concept|
QType:
make: S1 = list[int,2,3]
make: S2 = list[int,2,3]
test: <S1> * <S2>

QValue:
make: S1 = list[int,2,3]
make: S2 = list[int,2,2]
expr: H = <S1> * <S2>
hint: <H>
test: <S1> * <S2> == <?>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/Relation/Relation.concept|
QChoice: A relation:
g: Is a set of tuples.
b: Is a list of tuples.
b: Is a tuple of tuples.
b: Has ordered elements.
b: Can contain duplicates.
b: Has a fixed length.
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/ListRelation/ListRelation.concept|
QChoice: A relation:
g: Is a set of tuples.
b: Is a list of tuples.
b: Is a tuple of tuples.
b: Has ordered elements.
b: Can contain duplicates.
b: Has a fixed length.
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/List/List.concept|
QChoice: The type of a list is determined by:
g: The least upper bound of the type of all elements.
g: The types of all the elements in the list.
b: The type of the element that was first added to the list.
b: The average of the type of the elements with the smallest and the largest type.
b: The least upper bound of the type of two arbitrary elements.
b: The type of two arbitrary elements.


QValue:
desc: Fill in the missing operator.
make: B = arb[int[0,100],str]
make: A = list[same[B]]
expr: C = <A> + <B>
hint: Use +.
test: <A> <?> <B> == <C>

QValue:
desc: Fill in the missing operator.
prep: import Set;
make: DIFF = set[int[0,100]]
make: A = same[DIFF]
make: B = same[DIFF]
expr: A1 = toList(<DIFF> + <A>)
expr: B1 = toList(<B> + <DIFF>)
expr: C =  <A1> - <B1>
hint: Use -.
test: <A1> <?> <B1> == <C>

QValue:
desc: Fill in the missing operator.
prep: import List;
make: A = list[int[0,100]]
expr: B = reverse(<A>)
expr: C =  <A> == <B>
hint: Use ==.
test: (<A> <?> <B>) == <C>

QValue:
desc: Fill in the missing operator.
prep: import Set;
make: DIFF = set[int[0,100],str]
make: A = same[DIFF]
make: B = same[DIFF]
expr: A1 = toList(<DIFF> + <A>)
expr: B1 = toList(<B> + <DIFF>)
expr: C =  <A1> & <B1>
hint: Use &.
test: <A1> <?> <B1> == <C>

QValue:
desc: Fill in the missing operator.
prep: import Set;
make: ELM = int[0,100]
make: A = set[same[ELM]]
expr: A1 = toList( {<ELM>} + <A>)
expr: C =  <ELM> in <A1>
hint: Use in.
test: <ELM> <?> <A1> == <C>

QValue:
desc: Fill in the missing operator.
prep: import Set;
make: DIFF = set[int[0,100]]
make: A = same[DIFF]
expr: A1 = toList(<A>)
expr: B = toList(<A> + <DIFF>)
expr: C =  <A1> < <B>
hint: <C>
test: <A1> <?> <B> == <C>


QValue:
desc: Fill in the missing operator.
make: A = list[arb[int,str]]
make: B = same[A]
expr: C = <A> + <B>
hint: Use +.
test: <A> <?> <B> == <C>

QValue:
desc: Fill in the missing operator.
prep: import Set;
make: ELM = int[0,10]
make: A = list[same[ELM]]
expr: C =  <ELM> notin <A>
hint: Use notin.
test: <ELM> <?> <A> == <C>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/Real/Real.concept|
QType: <A:real>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Tutor/Markup/QuestionMarkup/Text/Text.concept|
QText[Taller]: What is taller, the Eiffel Tower or the Empire State Building?
a: Empire
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Tutor/Markup/QuestionMarkup/Type/Type.concept|
QType: <A:set[int]>

QType: <A:set[arb[int,str,real]]> + <B:same[A]>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/Relation/FieldSelection/FieldSelection.concept|
QValue:
hint: A set consisting of the first element of each tuple.
list:
rel[str animal, int nlegs] legs = {<"bird", 2>, <"dog", 4>, <"human", 2>, <"snake", 0>, <"spider", 8>, <"millepede", 1000>, <"crab", 8>, <"cat", 4>};
test: legs.animal == <?>

QValue:
hint: A set consisting of the second element of each tuple.
list:
rel[str animal, int nlegs] legs = {<"bird", 2>, <"dog", 4>, <"human", 2>, <"snake", 0>, <"spider", 8>, <"millepede", 1000>, <"crab", 8>, <"cat", 4>};
test: legs.nlegs == <?>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/Relation/ReflexiveTransitiveClosure/ReflexiveTransitiveClosure.concept|
QType:
prep: S = {<1,2>, <2,3>};
make: A = set[tuple[int[0,5],int[0,5]],1,2]
expr: B = <A> + S
test: <B>*

QValue:
prep: S = {<1,2>, <2,3>, <3,4>};
make: A = set[tuple[int[0,5],int[0,5]],1,2]
expr: B = <A> + S
expr: H =  <B>*
hint: <H>
test: <B>*
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/Relation/Join/Join.concept|
QType:  <A:set[tuple[int,str]]> join <B:set[tuple[str,int]]>
QValue: <A:set[tuple[int,str],2,2]> join <B:set[tuple[str,int],2,2]>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Reducer/Reducer.concept|
QValue:
desc: Return the set of largest words.
list:
import Number;
import String;
text = ["Quote", "from", "Steve", "Jobs", ":", "And", "one", "more", "thing"];
public list[str] largest(list[str] text){
  mx = ( 0 | max(it, size(s)) | s <- text );
  return
    for(s <- text)
        if(<?>)
           append s;
}
test: largest(text) == ["Quote", "Steve", "thing"];
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/Relation/Subscription/Subscription.concept|
QValue:
desc: Using the above example with GDP values:
prep: rel[str country, int year, int amount] GDP = {<"US", 2008, 14264600>, <"EU", 2008, 18394115>,<"Japan", 2008, 4923761>, <"US", 2007, 13811200>, <"EU", 2007, 13811200>, <"Japan", 2007, 4376705>};
expr: H = GDP["US"]
hint: <H>
test: GDP["US"] == <?>

QValue:
desc: Using the above example with GDP values:
prep: rel[str country, int year, int amount] GDP = {<"US", 2008, 14264600>, <"EU", 2008, 18394115>,<"Japan", 2008, 4923761>, <"US", 2007, 13811200>, <"EU", 2007, 13811200>, <"Japan", 2007, 4376705>};
expr: H = GDP["US",2008]
hint: <H>
test: GDP["US",2008] == <?>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/List/SubList/SubList.concept|
QType: <A:list[arb]> <= <B:same[A]>

QValue:
prep: import Set;
make: DIFF = set[int[0,100]]
make: A = same[DIFF]
expr: A1 = toList(<A>)
expr: B = toList(<A> + <DIFF>)
expr: C = <A1> <= <B>
hint: <C>
test: <A1> <= <B> == <?>

QValue:
make: A = list[arb[int,str,bool]]
expr: C = <A> <= <A>
hint: <C>
test: <A> <= <A>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Tutor/Markup/QuestionMarkup/Choice/Choice.concept|
QChoice[Faster]: Which means of transportation is faster?
b: Apache Helicopter
g: High speed train
b: Ferrari F430
b: Hovercraft
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/Relation/CartesianProduct/CartesianProduct.concept|
QType:
make: S1 = set[int,2,3]
make: S2 = set[int,2,3]
test: <S1> * <S2>

QValue:
make: S1 = set[int,2,3]
make: S2 = set[int,2,2]
expr: H = <S1> * <S2>
hint: <H>
test: <S1> * <S2> == <?>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/RascalTests/TestSoftwareEvolution/TestSoftwareEvolution.concept|
QChoice: Sets can be used to represent a sequence of values when
b: The values have duplicates.
g: The values have no duplicates and no order.
b: The values are unordered.

QChoice: The type of a list is determined by:
b: The type of the first element that was first added to the list.
b: The upperbound of the type of two arbitrary elements.
g: The upperbound of the type of all elements.

QType: <A:set[arb[int,real,str,loc]]>

QType: <A:list[arb[int,real,str,loc]]>

QType: <A:map[str,arb]>


QType: 
make: A = int
type: set[int]
test: {<A>, <?> } 
hint: one or more integer values separated by commas

QType: 
make: A = str
type: map[str,int]
test: (<A>: <?>)
hint: a map from strings to integers

QType: <A:set[arb[int,real,num,str,loc]]>

QType: {<A:int>, <B:str>, <C:int>}

QType: <A:rel[str,int,loc]>

QType: <A:rel[int[0,20],int]>

QValue:
desc: Determine the number of elements in a list
list:
import List;
text = ["abc", "def", "ghi"];
test: <?>(text) == 3;

QValue:
desc: Determine the number of strings that contain "a".
list:
text = ["andra", "moi", "ennepe", "Mousa", "polutropon"];
public int count(list[str] text){
  n = 0;
  for(s <- text)
    if(<?> := s)
      n +=1;
  return n;
}

test: count(text) == 2;

QValue:
desc: Return the strings that contain "o".
list:
text = ["andra", "moi", "ennepe", "Mousa", "polutropon"];
public list[str] find(list[str] text){
  return 
    for(s <- text)
      if(/o/ := s)
        <?>;
}
test: find(text) == ["moi", "Mousa", "polutropon"];

QValue:
desc: Complete this function that finds duplicates in a list of strings
list:
text = ["the", "jaws", "that", "bite", "the", "claws", "that", "catch"];
public list[str] duplicates(list[str] text){
    m = {};
    return 
      for(s <- text)
        if(<?>)
           append s;
        else
           m += s;
}
test: duplicates(text) == ["the", "that"];

QValue:
desc: Complete this function that tests that a list of words forms a palindrome. A palindrome is a word that is symmetrical 
and can be read
from left to right and from right to left.
list:
import List;
public bool isPalindrome(list[str] words){
  return words == <?>;
}
test: isPalindrome(["a", "b", "b", "a"]) == true;
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/List/Difference/Difference.concept|
QChoice: When you compute the difference of two lists, the number of elements in the result is always:
b: Greater than the number of elements in the first list.
b: Greater than the number of elements in the second list.
b: Greater than or equal to the sum of the number of elements in both lists.
g: Smaller than or equal to the number of elements in the first list.
b: Smaller than or equal to the number of elements in the second list.
b: Equal to the sum of the number of elements in both lists.

QType: 
make: A = list[arb[int[0,100],str]]
make: B = same[A]
test: <A> - <B>

QValue:
prep: import Set;
make: DIFF = set[int[0,100]]
make: A = same[DIFF]
make: B = same[DIFF]
expr: A1 = toList(<DIFF> + <A>)
expr: B1 = toList(<B> + <DIFF>)
expr: C =  <A1> - <B1>
hint: <C>
test: <A1> - <B1> == <?>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/List/Product/Product.concept|
QChoice: When you compute the product of two lists, the number of elements in the result is always:
b: Smaller than or equal to the number of elements in the first list.
b: Smaller than or equal to the number of elements in the second list.
g: Equal to the product of the number of elements in both lists.
b: Equal to the sum of the number of elements in both lists.
b: Equal to the number of elements in the largest list.


QType: <A:list[arb[int,str,bool]]> * <B:same[A]>

QValue: 
make: A = list[int[0,50]]
make: B = int[0,50]
expr: C = <A> * [<B>]
hint: <C>
test:  <A> * [<B>] == <?>

QValue: 
make: A = list[int[0,50]]
make: B = int[0,50]
make: C = int[0,50]
expr: D = <A> * [<B>, <C>]
hint: <D>
test:  <A> * [<B>, <C>] == <?>

QValue: 
prep: import List;
make: A = list[int[0,50]]
make: B = same[A]
expr: C = size(<A> * <B>)
hint: <C>
test:  size(<A> * <B>) == <?>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/List/NotEqual/NotEqual.concept|
QType: <A:list[arb]> != <B:same[A]>

QValue:
make: A = list[arb[int[0,10],str]]
expr: C =  <A> != <A>
hint: <C>
test: (<A> != <A>) == <?>

QValue:
make: A = list[int[0,100],str]
make: B = same[A]
expr: C =  <A> != <B>
hint: <C>
test: (<A> != <B>) == <?>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/List/Intersection/Intersection.concept|
QChoice: When you compute the intersection of two lists, the number of elements in the result is always:
b: Greater than the number of elements in the first list.
b: Greater than the number of elements in the second list.
b: Greater than or equal to the sum of the number of elements in both lists.
g: Smaller than or equal to the number of elements in the first list.
b: Smaller than or equal to the number of elements in the second list.
b: Equal to the sum of the number of elements in both lists.

QType: <A:list[int[0,100],str]> & <B:same[A]>

QValue:
prep: import Set;
make: DIFF = set[int[0,100],str]
make: A = same[DIFF]
make: B = same[DIFF]
expr: A1 = toList(<DIFF> + <A>)
expr: B1 = toList(<B> + <DIFF>)
expr: C =  <A1> & <B1>
hint: <C>
test: <A1> & <B1> == <?>

QValue:
make: A = list[int[0,10],str]
make: B = same[A]
expr: C =  <A> & <B>
hint: <C>
test: <A> & <B> == <?>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/List/Insert/Insert.concept|
QChoice: When you insert an element in a list, the number of elements in the result is always:
g: Greater than the number of elements in the original list.
g: One larger than the number of elements in the original list.
b: Smaller than the number of elements in the original list.
b: One smaller than the number of elements in the original list.
   
QType: 
make: A = arb[int[0,100],str]
make: B = list[same[A]]
test: <A> + <B>

QValue: 
make: A = arb[int[0,100],str]
make: B = list[same[A]]
hint:  <A> + <B>
test: <A> + <B> == <?>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/List/Subscription/Subscription.concept|
QChoice: For a list of length $N$, legal index value are:
g: The integers 0, 1, ..., N - 1.
b: Positive integers.
b: The integers 1, 2, ..., N.
b: Even integers.
b: Odd integers.
b: The integers, 0, 2, ..., N.

QValue:
prep: import List;
make: L = list[arb[bool,int,str],4,6]
make: I = int[0,3]
expr: C = <L>[<I>]
hint: <C>
list:
L = <L>;
test: L[<I>] == <?>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/List/in/in.concept|
QType: <A:arb[int,str,bool]> in <B:list[same[A]]>

QValue:
prep: import Set;
make: ELM = int[0,100]
make: A = set[same[ELM]]
expr: A1 = toList( {<ELM>} + <A>)
expr: C =  <ELM> in <A1>
hint: <C>
test: <ELM> in <A1> == <?>

QValue:
prep: import Set;
make: ELM = int[0,10]
make: A = list[same[ELM]]
expr: C =  <ELM> in <A>
hint: <C>
test: <ELM> in <A> == <?>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/List/Append/Append.concept|
QChoice: When you append an element to a list, the number of elements in the result is always:
g: Greater than the number of elements in the original list.
g: One larger than the number of elements in the original list.
b: Smaller than the number of elements in the original list.
b: One smaller than the number of elements in the original list.

QType: 
make: B = arb[int[0,100],str]
make: A = list[same[B]]
test: <A> + <B>

QValue:
make: B = arb[int[0,100],str]
make: A = list[same[B]]
expr: C = <A> + <B>
hint: <C>
test: <A> + <B> == <?>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/Boolean/Match/Match.concept|
QValue:
desc: Determine the number of strings that contain "a".
list:
text = ["andra", "moi", "ennepe", "Mousa", "polutropon"];
public int count(list[str] text){
  n = 0;
  for(s <- text)
    if(<?> := s)
      n +=1;
  return n;
}
test: count(text) == 2;
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Tutor/Markup/QuestionMarkup/Value/Value.concept|
QValue: <A:set[int]> + <B:same[A]>

QValue:
prep: import List;
test: size(<A:list[int]>) == <?>

QValue:
make: A = set[arb[int,str]]
make: B = same[A]
expr: C = <A> + <B>
hint: <B>
test: <A> + <?> == <C>

QValue:
desc: Return the strings that contain "o".
list:
text = ["andra", "moi", "ennepe", "Mousa", "polutropon"];
public list[str] find(list[str] text){
  return 
    for(s <- text)
      if(/o/ := s)
        <?>;
}
test: find(text) == ["moi", "Mousa", "polutropon"];
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/Set/notin/notin.concept|
QType: <A:arb[int,str,bool]> notin <B:set[same[A]]>


QValue:
make: ELM = int[0,100]
make: A = set[same[ELM]]
expr: A1 = {<ELM>, *<A>}
expr: C =  <ELM> notin <A1>
hint: <C>
test: <ELM> notin <A1> == <?>

QValue:
make: ELM = int[0,10]
make: A = set[same[ELM]]
expr: C =  <ELM> notin <A>
hint: <C>
test: <ELM> notin <A> == <?>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/List/StrictSuperList/StrictSuperList.concept|
QType: <A:list[arb]> > <B:same[A]>

QValue:
prep: import Set;
make: DIFF = set[int[0,100]]
make: B = same[DIFF]
expr: A = toList(<B> + <DIFF>)
expr: B1 = toList(<B>)
expr: C =  <A> > <B1>
hint: <C>
test: <A> > <B1> == <?>

QValue:
make: A = list[arb[int,str,bool]]
expr: C = <A> > <A>
hint: <C>
test: <A> > <A>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/Set/Set.concept|
QChoice: Sets can be used to represent a sequence of values when
b: The values have duplicates.
g: The values have no duplicates and no order.
b: The values are unordered.

QChoice: The type of a set is determined by:
g: The least upper bound of the type of all elements.
g: The types of all the elements in the set.
b: The type of the element that was first added to the set.
b: The average of the type of the elements with the smallest and the largest type.
b: The least upper bound of the type of two arbitrary elements.
b: The type of two arbitrary elements.


QType: {1, <?> }
type: set[int]
hint: one or more integer values separated by commas

QType: <A:set[arb[int,str]]>

QType: {<A:int>, <B:str>, <C:int>}

QValue:
desc: Fill in the missing operator.
make: ELM = int[0,100]
make: A = set[same[ELM]]
expr: A1 = {<ELM>} + <A>
expr: C =  <ELM> in <A1>
hint: in
test: <ELM> <?> <A1> == <C>

QValue: 
desc: Fill in the missing operator.
make: A = arb[int[0,100],str]
make: B = set[same[A]]
expr: H = <A> + <B>
hint: +
test: <A> <?> <B> == <H>

QValue:
desc: Fill in the missing operator.
make: DIFF = set[int[0,100],str]
make: A = same[DIFF]
make: B = same[DIFF]
expr: A1 = <DIFF> + <A>
expr: B1 = <B> + <DIFF>
expr: C =  <A1> & <B1>
hint: &
test: <A1> <?> <B1> == <C>


QValue:
desc: Fill in the missing operator.
prep: import Set;
make: DIFF = set[int[0,100]]
make: A = same[DIFF]
make: B = same[DIFF]
expr: A1 = <DIFF> + <A>
expr: B1 = <B> + <DIFF>
expr: C =  <A1> - <B1>
hint: -
test: <A1> <?> <B1> == <C>

QValue:
desc: Fill in the missing operator.
make: ELM = int[0,10]
make: A = set[same[ELM]]
expr: C =  <ELM> notin <A>
hint: notin
test: <ELM> <?> <A> == <C>

QValue:
desc: Fill in the missing operator.
make: DIFF = set[int[0,100]]
make: A = same[DIFF]
expr: B = <A> + <DIFF>
expr: C =  <A> < <B>
hint: <
test: <A> <?> <B> == <C>

QValue:
desc: Fill in the missing operator.
make: A = set[arb[int,str]]
make: B = same[A]
expr: C = <A> + <B>
hint: +
test: <A> <?> <B> == <C>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/Number/GreaterThan/GreaterThan.concept|
QType:  <A:int> > <B:int>
QType:  <A:real> > <B:real>
QType:  <A:num> > <B:num>
QType:  <A:num> > <B:num>
QValue: <A:num> > <B:num>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Patterns/Regular/Regular.concept|
QValue:
desc: Return the strings that contain "o".
list:
text = ["andra", "moi", "ennepe", "Mousa", "polutropon"];
public list[str] find(list[str] text){
  return 
    for(s <- text)
      if(/o/ := s)
        <?>;
}
test: find(text) == ["moi", "Mousa", "polutropon"];
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/ListRelation/TransitiveClosure/TransitiveClosure.concept|
QType:
prep: S = [<1,2>, <2,3>];
make: A = list[tuple[int[0,5],int[0,5]],1,2]
expr: B = <A> + S
test: <B>+

QValue:
prep: S = [<1,2>, <2,3>, <3,4>];
make: A = list[tuple[int[0,5],int[0,5]],1,2]
expr: B = <A> + S
expr: H =  <B>+
hint: <H>
test: <B>+
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/List/Equal/Equal.concept|
QType: <A:list[arb]> == <B:same[A]>

QValue:
make: A = list[arb[int[0,10],str]]
expr: C =  <A> == <A>
hint: <C>
test: (<A> == <A>) == <?>

QValue:
prep: import List;
make: A = list[int[0,100]]
expr: B = reverse(<A>)
expr: C =  <A> == <B>
hint: <C>
test: (<A> == <B>) == <?>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/List/Comprehension/Comprehension.concept|
QValue:
desc: Return the strings that contain a given substring.
list:
text = ["An", "honest", "man", "is", "always", "a", "child"]; 
public list[str] find(list[str] text, str contains) = [ s | s <- text, <?> ];
test: find(text, "n") == ["An", "honest", "man"];
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/Number/LessThan/LessThan.concept|
QType:  <A:int> < <A:int>
QType:  <A:real> < <B:real>
QType:  <A:num> < <B:num>
QType:  <A:num> < <B:num>
QValue: <A:num> < <B:num>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/Number/Negation/Negation.concept|
QType:  -<A:int>
QType:  -<A:real>
QValue: -<A:num>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/Number/Multiplication/Multiplication.concept|
QType:  <A:int> * <B:int>
QType:  <A:int> * <B:real>
QType:  <A:real> * <B:int>
QValue: <A:num> * <B:num>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Statements/If/If.concept|
QType: if( <A:int> > <B:int> ) 10; else 20;

QType: if( <A:int> > <B:int> ) <C:str>; else <D:str>;

QValue: if( <A:int> > <B:int> ) 10; else 20;
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/Number/Division/Division.concept|
QType:  <A:int> / <B:int>
QType:  <A:int> / <B:real>
QType:  <A:real> / <B:int>
QValue: <A:num> / <B:num>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Statements/Append/Append.concept|
QValue:
desc: Complete this function that finds duplicates in a list of strings
list:
text = ["the", "jaws", "that", "bite", "the", "claws", "that", "catch"];
public list[str] duplicates(list[str] text){
    m = {};
    return 
      for(s <- text)
        if(<?>)
           append s;
        else
           m += s;
}
test: duplicates(text) == ["the", "that"];
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/Number/Addition/Addition.concept|
QType: <A:int[0]> + <B:int[0]>
desc: Adding integers. 

QValue: <A:int[0]> + <B:int[0]> 
desc: Adding integers. 

QType:<A:int[0]> + <B:real[0]>
desc: Adding integers and reals.

QValue:<A:int[0]> + <B:real[0]> 
Adding integers and reals.

QValue: <A:int> + (<B:int[-20,-1]>)
desc:Use parentheses when addition and negative numbers interact.

QValue: 
desc: Use parentheses when addition and negative numbers interact.
make: A = int
make: B = int[0,10]
expr: C = <A> - <B>
test: <A> + <?> == <C>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/Number/GreaterThanOrEqual/GreaterThanOrEqual.concept|
QType:  <A:int> >= <B:int>
QType:  <A:real> >= <B:real>
QType:  <A:num> >= <B:num>
QType:  <A:num> >= <B:num>
QValue: <A:num> >= <B:num>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/Number/NotEqual/NotEqual.concept|
QType:  <A:int> != <B:int>
QType:  <A:real> != <B:real>
QType:  <A:num> != <B:num>
QType:  <A:num> != <B:num>
QValue: <A:num> != <B:num>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/List/StrictSubList/StrictSubList.concept|
QType: <A:list[arb]> < <B:same[A]>

QValue:
prep: import Set;
make: DIFF = set[int[0,100]]
make: A = same[DIFF]
expr: A1 = toList(<A>)
expr: B = toList(<A> + <DIFF>)
expr: C =  <A1> < <B>
hint: <C>
test: <A1> < <B> == <?>

QValue:
make: A = list[arb[int,str,bool]]
expr: C = <A> < <A>
hint: <C>
test: <A> < <A>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/Relation/TransitiveClosure/TransitiveClosure.concept|
QType:
prep: S = {<1,2>, <2,3>};
make: A = set[tuple[int[0,5],int[0,5]],1,2]
expr: B = <A> + S
test: <B>+

QValue:
prep: S = {<1,2>, <2,3>, <3,4>};
make: A = set[tuple[int[0,5],int[0,5]],1,2]
expr: B = <A> + S
expr: H =  <B>+
hint: <H>
test: <B>+
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/Tuple/Tuple.concept|
QChoice: For a tuple:
g: All elements may have different types.
b: All elements should have the same type.
g: It's type changes with the number of elements.
b: It's type does not change with the number of elements.
g: The order of the elements is relevant.
b: The order of the elements is not relevant.
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/Set/Difference/Difference.concept|
QChoice: When you compute the difference of two sets, the number of elements in the result is always:
b: Greater than the number of elements in both sets.
b: Greater than or equal to the number of elements in the first set.
b: Smaller than the number of elements in both sets.
g: Smaller than or equal to the number of elements in the first set.

QType: <A:set[arb[int,str]]> - <B:same[A]>

QType: <A:set[arb[str,int]]> - <A:same[A]>

QValue:
prep: import Set;
make: DIFF = set[int[0,100]]
make: A = same[DIFF]
make: B = same[DIFF]
expr: A1 = <DIFF> + <A>
expr: B1 = <B> + <DIFF>
expr: C =  <A1> - <B1>
hint: <C>
test: <A1> - <B1> == <?>

QValue:
prep: import Set;
make: DIFF = set[int[0,100]]
make: A = same[DIFF]
make: B = same[DIFF]
expr: A1 = <DIFF> + <A>
expr: B1 = <B> + <DIFF>
expr: C =  <A1> - <B1>
hint: <A1>
test: <?> - <B1> == <C>

QValue:
prep: import Set;
make: DIFF = set[int[0,100]]
make: A = same[DIFF]
make: B = same[DIFF]
expr: A1 = <DIFF> + <A>
expr: B1 = <B> + <DIFF>
expr: C =  <A1> - <B1>
hint: <B1>
test: <A1> - <?> == <C>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/Set/NotEqual/NotEqual.concept|
QType: <A:list[arb]> != <B:same[A]>

QValue:
make: A = set[arb[int[0,10],str]]
expr: C =  <A> != <A>
hint: <C>
test: (<A> != <A>) == <?>

QValue:
make: A = set[int[0,100],str]
make: B = same[A]
expr: C =  <A> != <B>
hint: <C>
test: (<A> != <B>) == <?>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/Set/StrictSuperSet/StrictSuperSet.concept|
QType: <A:list[arb]> > <B:same[A]>

QValue:
make: DIFF = set[int[0,100]]
make: B = same[DIFF]
expr: A = <B> + <DIFF>
expr: C =  <A> > <B>
hint: <C>
test: <A> > <B> == <?>

QValue:
make: A = set[arb[int,str,bool]]
expr: C = <A> > <A>
hint: <C>
test: <A> > <A>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/Set/StrictSubSet/StrictSubSet.concept|
QType: <A:set[arb[int,str]]> < <B:same[A]>

QValue:
make: DIFF = set[int[0,100]]
make: A = same[DIFF]
expr: B = <A> + <DIFF>
expr: C =  <A> < <B>
hint: <C>
test: <A> < <B> == <?>

QValue:
make: A = set[arb[int,str,bool]]
expr: C = <A> < <A>
hint: <C>
test: <A> < <A>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/Set/SuperSet/SuperSet.concept|
QType: <A:set[arb]> >= <B:same[A]>


QValue:
make: DIFF = set[int[0,100]]
make: B = same[DIFF]
expr: A = <B> + <DIFF>
expr: C =  <A> >= <B>
hint: <C>
test: <A> >= <B> == <?>

QValue:
make: A = set[arb[int,str,bool]]
expr: C = <A> >= <A>
hint: <C>
test: <A> >= <A>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/Set/Product/Product.concept|
QType: <A:list[arb[int,str,bool]]> * <B:same[A]>

QValue: 
make: A = set[int[0,50]]
make: B = int[0,50]
expr: C = <A> * {<B>}
hint: <C>
test:  <A> * {<B>} == <?>

QValue: 
make: A = set[int[0,50]]
make: B = int[0,50]
make: C = int[0,50]
expr: D = <A> * {<B>, <C>}
hint: <D>
test:  <A> * {<B>, <C>} == <?>

QValue: 
prep: import Set;
make: A = set[int[0,50]]
make: B = same[A]
expr: C = size(<A> * <B>)
hint: <C>
test:  size(<A> * <B>) == <?>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/Set/Union/Union.concept|
QChoice: When you compute the union of two sets, the number of elements in the result is always:
g: Smaller than or equal to the total number of elements in both sets.
b: Greater than or equal to the number of elements in both sets.
b: Greater than the number of elements in both sets.
b: Smaller than the number of elements in both sets.

QType: <A:set[arb[int,str,real]]> + <B:same[A]>

QValue: <A:set[arb[int,str,real]]> + <B:same[A]>

QValue:
make: A = set[arb[int,str]]
make: B = same[A]
expr: C = <A> + <B>
hint: <B>
test: <A> + <?> == <C>

QValue: <A:set[arb[0,int,str]]> + <B:same[A]>

QValue: <A:set[arb[0,int,str]]> + {}
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/Set/SubSet/SubSet.concept|
QType: <A:set[arb[0,int,str,real]]> <= <B:same[A]>

QValue:
make: DIFF = set[int[0,100]]
make: A = same[DIFF]
expr: B = <A> + <DIFF>
expr: C = <A> <= <B>
hint: <C>
test: <A> <= <B> == <?>

QValue:
make: A = set[arb[int,str,bool]]
expr: C = <A> <= <A>
hint: <C>
test: <A> <= <A>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/Set/Insert/Insert.concept|
QChoice: When you insert an element in a set, the number of elements in the result is always:
g: Greater than or equal to the number of elements in the original set.
g: One larger than the number of elements in the original set.
b: Smaller than the number of elements in the original set.
b: One smaller than the number of elements in the original set.
   
QType: 
make: A = arb[int[0,100],str]
make: B = set[same[A]]
test: <A> + <B>

QValue: 
make: A = arb[int[0,100],str]
make: B = set[same[A]]
expr: H = <A> + <B>
hint: <H>
test: <A> + <B> == <?>

QValue: 
make: A = arb[int[0,100],str]
make: B = set[same[A]]
expr: H = <B> + <A>
hint: <H>
test: <B> + <A> == <?>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/Set/Intersection/Intersection.concept|
QChoice: When you compute the intersection of two sets, the number of elements in the result is always:
b: Greater than the number of elements in both sets.
b: Greater than or equal to the number of elements in both sets.
b: Smaller than the number of elements in both sets.
g: Smaller than or equal to the number of elements in the smallest set.


QType: <A:list[int[0,100],str]> & <B:same[A]>

QValue:
make: DIFF = set[int[0,100],str]
make: A = same[DIFF]
make: B = same[DIFF]
expr: A1 = <DIFF> + <A>
expr: B1 = <B> + <DIFF>
expr: C =  <A1> & <B1>
hint: <C>
test: <A1> & <B1> == <?>

QValue:
make: A = set[int[0,10],str]
make: B = same[A]
expr: C =  <A> & <B>
hint: <C>
test: <A> & <B> == <?>
conceptFile: |file:///Users/paulklint/git/rascal/src/org/rascalmpl/courses/Rascal/Expressions/Values/Set/in/in.concept|
QType: <A:arb[int,str,bool]> in <B:list[same[A]]>

QValue:
make: ELM = int[0,100]
make: A = set[same[ELM]]
expr: A1 = {<ELM>} + <A>
expr: C =  <ELM> in <A1>
hint: <C>
test: <ELM> in <A1> == <?>

QValue:
prep: import Set;
make: ELM = int[0,10]
make: A = set[same[ELM]]
expr: C =  <ELM> in <A>
hint: <C>
test: <ELM> in <A> == <?>
value: true

conceptFile: List.rsc:

Questions:

QValue:
desc: Fill in the missing function name.
prep: import List;
make: L = list[arb[int,str],4,6]
make: I = int[0,3]
expr: E = <L>[<I>]
expr: H = indexOf(<L>, <E>)
hint: indexOf
test: <?>(<L>, <E>) == <H>

QValue:
desc: Fill in the missing function name.
prep: import List;
make: E = arb[int,str]
make: L = list[same[E],4,6]
make: I = int[0,3]
expr: H = insertAt(<L>, <I>, <E>)
hint: insertAt
test: <?>(<L>, <I>, <E>) == <H>

QValue:
desc: Fill in the missing function name.
prep: import List;
make: L = list[int,0,5]
expr: H = intercalate(";", <L>) 
hint: intercalate
test: <?>(";", <L>) == <H>


QValue:
desc: Fill in the missing function name.
prep: import List;
make: L = list[arb[int,str],0,5]
expr: H = index(<L>)
hint: index
test: <?>(<L>) == <H>

QValue:
desc: Fill in the missing function name.
prep: import List;
make: L = list[arb[int,str],1,6]
expr: H = head(<L>)
hint: head
test: <?>(<L>) == <H>

QValue:
desc: Fill in the missing function name.
prep: import List;
make: L = list[arb[int,str], 1, 6]
expr: H =  last(<L>)
hint: last
test: <?>(<L>) == <H>

QValue:
desc: Fill in the missing function name.
prep: import List;
make: L = list[arb[int,str]]
expr: H = toSet(<L>)
hint: toSet
test: <?>(<L>) == <H>

QValue:
desc: Fill in the missing function name.
prep: import List;
make: L = list[arb[bool,int,str],4,6]
make: N = int[0,3]
expr: H = take(<N>, <L>)
hint: take
test: <?>(<N>, <L>) == <H>

QValue:
desc: Fill in the missing function name.
prep: import List;
make: L = list[arb[bool,int,str],4,6]
make: N = int[0,3]
expr: H = tail(<L>,<N>)
hint: tail
test: <?>(<L>,<N>) == <H>


QValue:
desc: Fill in the missing function name.
prep: import List;
make: L = list[arb[int,str],1,5]
expr: H = headTail(<L>)
hint: Use headTail.
test: <?>(<L>) == <H>

QValue:
desc: Fill in the missing function name.
prep: import List;
make: L = list[arb[bool,int,str],4,6]
make: I = int[0,3]
make: J = int[0,3]
expr: L1 = [<L>[<I>], <L>[<J>], *<L>, <L>[<J>], <L>[<I>]]
expr: H = dup(<L1>)
hint: dup
test: <?>(<L1>) == <H>

QValue:
desc: Fill in the missing function name.
prep: import List;
make: L = list[arb[bool,int,str],2,5]
expr: H = getOneFrom(<L>)
hint: getOneFrom
test: <?>(<L>) == <H>

QValue:
desc: Fill in the missing function name.
prep: import List;
make: L = list[arb[bool,int,str],3,4]
make: N = int[0,2]
expr: H = drop(<N>, <L>)
hint: drop
test: <?>(<N>, <L>) == <H>

QValue:
desc: Fill in the missing function name.
prep: import List;
make: L = list[arb[int,str],0,5]
expr: H =  reverse(<L>) 
hint: reverse
test: <?>(<L>) == <H>

QValue:
desc: Fill in the missing function name.
prep: import List;
make: L = list[arb[int,str],3,4]
make: I = int[0,2]
expr: E = <L>[<I>]
expr: L1 = reverse(<L>) + <L>
expr: H = lastIndexOf(<L1>, <E>)
hint: lastIndexOf
test: <?>(<L1>, <E>) == <H>

QValue:
desc: Fill in the missing function name.
prep: import List;
make: L = list[arb[int,str],0,5]
expr: H = index(<L>)
hint: index
test: <?>(<L>) == <H>

QValue:
desc: Fill in the missing function name.
prep: import List;
make: L = list[arb[int,str],1,5]
expr: H = pop(<L>)
hint: pop
test: <?>(<L>) == <H>


QValue:
prep: import List;
make: L = list[arb[int,str], 1, 6]
expr: H = max(<L>)
hint: max
test: <?>(<L>) == <H>

QValue:
desc: Fill in the missing function name.
prep: import List;
make: L = list[int[-20,20]]
expr: H = takeWhile(<L>, bool(int x){ return x > 0;})
hint: takeWhile
test: <?>(<L>, bool(int x){ return x > 0;}) == <H>

QValue:
desc: Fill in the missing function name.
prep: import List;
make: L = list[arb[int,str],3,4]
make: I = int[0,2]
expr: C = delete(<L>, <I>)
hint: delete
test: <?>(<L>, <I>) == <C>

QValue:
desc: Fill in the missing function name.
prep: import List;
make: L = list[int,2,7]
expr: H = sum(<L>)
hint: sum
test: <?>(<L>) == <H>

QValue:
desc: Fill in the missing function name.
prep: import List;
make: L = list[int, 4, 4]
make: M = list[int, 4, 4]
expr: Z = zip(<L>,<M>)
hint: zip
test: <?>(<L>, <M>) == <Z>


QValue:
desc: Fill in the missing function name.
prep: import List;
make: L = list[arb[int,str],1,5]
expr: H = sort(<L>)
hint: sort
test: <?>(<L>) == <H>


QValue:
prep: import List;
make: L = list[int, 1,5]
expr: H = mapper(<L>, int(int n){ return n + 1; })
hint: mapper
list:
int incr(int x) { return x + 1; }
test: <?>(<L>, incr) == <H>

QValue:
desc: Complete this function that tests that a list of words forms a palindrome. A palindrome is a word that is symmetrical 
and can be read
from left to right and from right to left.
list:
import List;
public bool isPalindrome(list[str] words){
  return words == <?>;
}
test: isPalindrome(["a", "b", "b", "a"]) == true;


